<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XrossStars デッキ構築</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 1rem auto;
            padding: 1rem;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        .section-title {
            font-size: 1.75rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 0.75rem;
        }
        .input-group {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
        }
        .input-field {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.2s;
        }
        .input-field:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }
        .btn-primary {
            background-color: #3b82f6;
            color: white;
        }
        .btn-primary:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: #ef4444;
            color: white;
        }
        .btn-danger:hover {
            background-color: #dc2626;
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #6b7280;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #4b5563;
        }
        .card-list {
            background-color: #f9fafb;
            border-radius: 8px;
            padding: 1rem;
            min-height: 100px;
            border: 1px dashed #d1d5db;
        }
        .card-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e5e7eb;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .card-item:last-child {
            border-bottom: none;
        }
        .card-info {
            flex-grow: 1;
            min-width: 0;
        }
        .card-detail-line {
            display: block;
            font-size: 0.875rem;
            color: #4b5563;
            margin-top: 0.25rem;
        }
        .card-detail-line:first-of-type {
            margin-top: 0;
        }
        .card-controls {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 0.5rem;
            margin-left: 1rem;
            flex-shrink: 0;
        }
        .quantity-btn {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            background-color: #60a5fa;
            color: white;
            transition: background-color 0.2s;
            width: 30px;
            text-align: center;
        }
        .quantity-btn:hover {
            background-color: #3b82f6;
        }
        .quantity-display {
            font-weight: 600;
            padding: 0.25rem 0.5rem;
            min-width: 30px;
            text-align: center;
        }
        .validation-message {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            margin-top: 1rem;
            font-weight: 600;
        }
        .validation-success {
            background-color: #d1fae5;
            color: #065f46;
        }
        .validation-warning {
            background-color: #fef3c7;
            color: #92400e;
        }
        .validation-error {
            background-color: #fee2e2;
            color: #991b1b;
        }
        /* Autocomplete styles */
        .autocomplete-suggestions {
            border: 1px solid #d1d5db;
            background: #fff;
            overflow: auto;
            max-height: 150px;
            border-radius: 8px;
            z-index: 10;
            position: absolute;
            width: calc(100% - 2rem);
            margin-top: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .autocomplete-suggestion {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #e5e7eb;
        }
        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }
        .autocomplete-suggestion:hover {
            background-color: #e0f2fe;
        }
        .autocomplete-selected {
            background-color: #bfdbfe;
        }
        .input-container {
            position: relative;
            flex-grow: 1;
        }
        /* Card Catalog Table Styles */
        .card-catalog-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem;
            font-size: 0.9rem;
            table-layout: fixed;
        }
        .card-catalog-table th, .card-catalog-table td {
            border: 1px solid #e5e7eb;
            padding: 0.75rem;
            text-align: left;
            vertical-align: top;
        }
        .card-catalog-table th {
            background-color: #e0f2fe;
            font-weight: 600;
            color: #2c3e50;
            position: sticky;
            top: 0;
            z-index: 5;
        }
        .card-catalog-table tbody tr:nth-child(even) {
            background-color: #f9fafb;
        }
        .card-catalog-table tbody tr:hover {
            background-color: #e0f7fa;
        }
        .table-scroll-container {
            max-height: 500px;
            overflow-y: auto;
            border-radius: 8px;
            border: 1px solid #d1d5db;
        }
        /* Card Image Grid Styles (Updated for responsiveness) */
        .card-image-grid {
            /* These Tailwind classes will be applied directly in JS to override this */
            display: grid;
            gap: 1rem;
            padding: 1rem;
            background-color: #f9fafb;
            border-radius: 8px;
            border: 1px dashed #d1d5db;
            max-height: 70vh;
            overflow-y: auto;
        }
        .card-image-item {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 0.5rem;
            cursor: pointer;
            transition: transform 0.1s ease-in-out;
        }
        .card-image-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }
        .card-image-item img {
            width: 100%;
            height: auto;
            border-bottom: 1px solid #e5e7eb;
            object-fit: contain;
            /* Placeholder specific styling */
            background-color: #e0e0e0;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: #666;
            text-align: center;
            padding: 0.5rem;
        }

        .card-image-controls {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            padding: 0.5rem 0.25rem;
        }
        .card-image-controls button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            color: #60a5fa;
            transition: color 0.2s;
        }
        .card-image-controls button:hover {
            color: #2563eb;
        }
        .card-image-quantity {
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-content {
            background-color: #fff;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            position: relative;
        }
        .modal-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.8rem;
            cursor: pointer;
            color: #888;
        }
        .modal-close-btn:hover {
            color: #333;
        }

        /* Specific Column Widths for Leader Card Catalog */
        #leaderCardCatalogTableBody th:nth-child(1), #leaderCardCatalogTableBody td:nth-child(1) { width: 18%; } /* カード名 */
        #leaderCardCatalogTableBody th:nth-child(2), #leaderCardCatalogTableBody td:nth-child(2) { width: 8%; }  /* タグ */
        #leaderCardCatalogTableBody th:nth-child(3), #leaderCardCatalogTableBody td:nth-child(3) { width: 7%; }  /* 色 */
        #leaderCardCatalogTableBody th:nth-child(4), #leaderCardCatalogTableBody td:nth-child(4) { width: 7%; }  /* HP */
        #leaderCardCatalogTableBody th:nth-child(5), #leaderCardCatalogTableBody td:nth-child(5) { width: 7%; }  /* ATK */
        #leaderCardCatalogTableBody th:nth-child(6), #leaderCardCatalogTableBody td:nth-child(6) { width: 33%; } /* カードテキスト */
        #leaderCardCatalogTableBody th:nth-child(7), #leaderCardCatalogTableBody td:nth-child(7) { width: 20%; } /* Add Controls */

        /* Specific Column Widths for Main Card Catalog */
        #mainCardCatalogTableBody th:nth-child(1), #mainCardCatalogTableBody td:nth-child(1) { width: 15%; } /* カード名 */
        #mainCardCatalogTableBody th:nth-child(2), #mainCardCatalogTableBody td:nth-child(2) { width: 9%; }  /* 種類 */
        #mainCardCatalogTableBody th:nth-child(3), #mainCardCatalogTableBody td:nth-child(3) { width: 7%; }  /* 色 */
        #mainCardCatalogTableBody th:nth-child(4), #mainCardCatalogTableBody td:nth-child(4) { width: 7%; }  /* コスト */
        #mainCardCatalogTableBody th:nth-child(5), #mainCardCatalogTableBody td:nth-child(5) { width: 13%; } /* ビルドルール */
        #mainCardCatalogTableBody th:nth-child(6), #mainCardCatalogTableBody td:nth-child(6) { width: 29%; } /* カードテキスト */
        #mainCardCatalogTableBody th:nth-child(7), #mainCardCatalogTableBody td:nth-child(7) { width: 20%; } /* Add Controls */


        /* Specific Column Widths for Tactics Card Catalog */
        #tacticsCardCatalogTableBody th:nth-child(1), #tacticsCardCatalogTableBody td:nth-child(1) { width: 25%; } /* カード名 */
        #tacticsCardCatalogTableBody th:nth-child(2), #tacticsCardCatalogTableBody td:nth-child(2) { width: 15%; } /* 種類 */
        #tacticsCardCatalogTableBody th:nth-child(3), #tacticsCardCatalogTableBody td:nth-child(3) { width: 10%; } /* コスト */
        #tacticsCardCatalogTableBody th:nth-child(4), #tacticsCardCatalogTableBody td:nth-child(4) { width: 30%; } /* カードテキスト */
        #tacticsCardCatalogTableBody th:nth-child(5), #tacticsCardCatalogTableBody td:nth-child(5) { width: 20%; } /* Add Controls */

        /* Styles for generated deck image text */
        .deck-image-card-name {
            font-size: 10px; /* Smaller font for card names on the image */
            text-align: center;
            margin-top: 2px;
            color: #333;
            font-weight: 600;
            width: 100%;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        /* Canvas scaling for responsiveness within modal */
        #deckCanvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

    </style>
</head>
<body class="p-4">
    <div class="container">
        <h1 class="text-4xl font-extrabold text-center mb-8 text-blue-800">
            XrossStars<br>デッキ構築
        </h1>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="hidden fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-white p-6 rounded-lg shadow-xl flex items-center space-x-4">
                <svg class="animate-spin h-8 w-8 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p class="text-lg text-gray-700">カードデータを読み込み中...</p>
            </div>
        </div>

        <!-- Top Navigation and Deck Button -->
        <div class="flex flex-col gap-3 mb-6">
            <div class="flex justify-center gap-3">
                <button id="showDeckBtn" class="btn btn-primary px-5 py-2.5">デッキ</button>
                <button id="generateDeckImageBtn" class="btn btn-primary px-5 py-2.5">デッキ画像</button>
            </div>
            <div class="flex justify-center gap-3">
                <button id="showLeaderCatalogBtn" class="btn btn-primary px-5 py-2.5">リーダー</button>
                <button id="showMainCatalogBtn" class="btn btn-primary px-5 py-2.5">メイン</button>
                <button id="showTacticsCatalogBtn" class="btn btn-primary px-5 py-2.5">タクティクス</button>
            </div>
        </div>

        <!-- Search, Sort, Display Toggle -->
        <div class="flex flex-wrap items-center gap-4 mb-6 p-4 bg-blue-50 rounded-lg shadow-inner">
            <div class="input-container flex-grow max-w-sm">
                <input type="text" id="searchCatalogInput" placeholder="カードを検索..." class="input-field w-full">
            </div>
            
            <select id="colorFilterSelect" class="p-2 border border-gray-300 rounded-md">
                <option value="全て">色</option>
                <option value="赤">赤</option>
                <option value="青">青</option>
                <option value="黄">黄</option>
                <option value="緑">緑</option>
            </select>

            <select id="cardTypeFilterSelect" class="p-2 border border-gray-300 rounded-md">
                <option value="全て">種類</option>
                <option value="アタックカード">アタックカード</option>
                <option value="メモリアカード">メモリアカード</option>
            </select>

            <select id="costFilterSelect" class="p-2 border border-gray-300 rounded-md">
                <option value="全て">コスト</option>
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4+">4+</option>
            </select>

            <label id="buildRuleCheckboxLabel" class="flex items-center space-x-2">
                <input type="checkbox" id="buildRuleCheckbox" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                <span class="text-gray-800">ビルドルールあり</span>
            </label>

            <select id="sortCriterion" class="p-2 border border-gray-300 rounded-md">
                <option value="カード名">カード名でソート</option>
                <option value="コスト">コストでソート</option>
                <option value="レアリティ">レアリティでソート</option>
                <option value="色">色でソート</option>
            </select>
            <button id="sortDirectionBtn" class="btn btn-primary px-4 py-2">昇順</button>
            <button id="toggleDisplayBtn" class="btn btn-secondary px-4 py-2">表示切替: 画像一覧</button>
        </div>
        
        <!-- Card Catalog Display Area (Dynamic Content) -->
        <div id="catalogDisplayArea">
            <!-- Content will be rendered here dynamically (image grid or table) -->
        </div>

        <!-- Validation and Summary Section -->
        <div class="mt-8 p-6 bg-gray-50 rounded-lg shadow-inner">
            <h2 class="section-title">現在のデッキ状況</h2>
            <div id="leaderValidation" class="validation-message validation-warning mb-2">
                リーダーカードは現在 <span id="currentLeaderCount">0</span>/4 枚です。
            </div>
            <div id="mainDeckSummary" class="p-4 bg-blue-50 rounded-lg text-blue-800 font-semibold mb-2">
                メインデッキ: <span id="totalMainCards">0</span>/50 枚 | エースカード: <span id="totalAceCards">0</span>/8 枚
            </div>
            <div id="mainDeckValidation" class="validation-message validation-warning mb-2">
                メインデッキの枚数とルールの確認。
            </div>
            <div id="tacticsValidation" class="validation-message validation-warning">
                タクティクスカードは現在 <span id="currentTacticsCount">0</span>/5 枚です。
            </div>
        </div>

        <!-- Export/Import Section -->
        <div class="mb-8 p-6 bg-blue-50 rounded-lg shadow-inner">
            <h2 class="section-title">デッキの入出力</h2>
            <button id="toggleExportImportBtn" class="btn btn-secondary w-full mb-4">入出力セクションを表示/非表示</button>
            <div id="exportImportContent" class="hidden">
                <div class="input-group">
                    <label for="deckNameInput" class="font-semibold text-gray-700">デッキ名:</label>
                    <input type="text" id="deckNameInput" placeholder="デッキ名を入力" class="input-field">
                </div>
                <div class="flex flex-col gap-4">
                    <div>
                        <button id="exportDeckBtn" class="btn btn-primary w-full">デッキをエクスポート</button>
                        <button id="copyExportedDataBtn" class="btn btn-primary w-full mt-2 hidden">コピー</button>
                    </div>
                    <textarea id="deckDataTextarea" class="input-field h-40 text-sm" placeholder="ここにデッキデータが表示されます（エクスポート/インポート用）。"></textarea>
                    <div>
                        <button id="importDeckBtn" class="btn btn-primary w-full">デッキをインポート</button>
                    </div>
                    <div id="importExportMessage" class="validation-message hidden"></div>
                </div>
            </div>
        </div>

    </div>

    <!-- Deck View Modal -->
    <div id="deckViewModal" class="modal-overlay hidden">
        <div class="modal-content w-11/12 md:w-3/4 lg:w-2/3">
            <button class="modal-close-btn" id="closeDeckViewModal">&times;</button>
            <h3 class="text-2xl font-bold mb-4">現在のデッキ: <span id="modalDeckName"></span></h3>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
                <div>
                    <h4 class="font-semibold text-lg mb-2">リーダーカード (<span id="modalLeaderCount">0</span>/4)</h4>
                    <div id="modalLeaderCards" class="flex flex-wrap gap-2"></div>
                </div>
                <div>
                    <h4 class="font-semibold text-lg mb-2">メインデッキ (<span id="modalMainCount">0</span>/50)</h4>
                    <div id="modalMainCards" class="flex flex-wrap gap-2"></div>
                </div>
                <div>
                    <h4 class="font-semibold text-lg mb-2">タクティクスデッキ (<span id="modalTacticsCount">0</span>/5)</h4>
                    <div id="modalTacticsCards" class="flex flex-wrap gap-2"></div>
                </div>
            </div>
            <div class="text-sm text-gray-600">
                <p>エースカード: <span id="modalAceCount">0</span>/8</p>
            </div>
        </div>
    </div>

    <!-- Card Detail Modal -->
    <div id="cardDetailModal" class="modal-overlay hidden">
        <div class="modal-content w-11/12 md:w-1/2 lg:w-1/3">
            <button class="modal-close-btn" id="closeCardDetailModal">&times;</button>
            <img id="modalCardImage" src="" alt="Card Image" class="w-full h-auto rounded-lg mb-4">
            <h3 id="modalCardName" class="text-xl font-bold mb-2"></h3>
            <p id="modalCardNumber" class="text-sm text-gray-600 mb-1"></p>
            <p id="modalCardType" class="text-sm text-gray-600 mb-1"></p>
            <p id="modalCardColor" class="text-sm text-gray-600 mb-1"></p>
            <p id="modalCardCost" class="text-sm text-gray-600 mb-1"></p>
            <p id="modalCardRarity" class="text-sm text-gray-600 mb-1"></p>
            <p id="modalCardRules" class="text-sm text-gray-600 mb-1"></p>
            <p id="modalCardTag" class="text-sm text-gray-600 mb-1"></p>
            <p id="modalCardStats" class="text-sm text-gray-600 mb-1"></p>
            <p id="modalCardText" class="text-base text-gray-800 whitespace-pre-wrap mt-2"></p>
        </div>
    </div>

    <!-- Deck Image Modal -->
    <div id="deckImageModal" class="modal-overlay hidden">
        <div class="modal-content max-w-full max-h-full p-4">
            <button class="modal-close-btn" id="closeDeckImageModal">&times;</button>
            <h3 class="text-2xl font-bold mb-4 text-center">生成されたデッキ画像</h3>
            <div class="flex flex-col items-center">
                <canvas id="deckCanvas" class="border border-gray-300 rounded-md shadow-lg"></canvas>
                <a id="downloadDeckImage" download="XrossStars_Deck_Image.png" class="btn btn-primary mt-4 py-2 px-6">画像をダウンロード</a>
            </div>
        </div>
    </div>

    <script>
        // デッキの状態を管理する配列
        let leaderDeck = [];
        let mainDeck = []; // { name: string, quantity: number, isAce: boolean, cardData: Object }
        let tacticsDeck = [];
        let deckName = ""; // デッキ名

        // 全てのカードデータを格納するオブジェクト
        let allCardData = {}; // Key: カード名, Value: カードオブジェクト
        let allCardDataByNumberPrefix = {}; // Key: カードナンバーの"/"以前, Value: カードオブジェクト

        // UI表示に関する状態
        let currentTab = 'leader'; // 'leader', 'main', 'tactics' - デフォルトをリーダーに変更
        let displayMode = 'image'; // 'image' or 'table'
        let currentSearchQuery = '';
        let currentSort = { criterion: 'カード名', direction: 'asc' };

        // フィルターの状態
        let selectedFilterColor = '全て';
        let selectedFilterCardType = '全て';
        let selectedFilterCost = '全て';
        let onlyBuildRule = false;


        // HTML要素への参照
        const loadingIndicator = document.getElementById('loadingIndicator');

        const showLeaderCatalogBtn = document.getElementById('showLeaderCatalogBtn');
        const showMainCatalogBtn = document.getElementById('showMainCatalogBtn');
        const showTacticsCatalogBtn = document.getElementById('showTacticsCatalogBtn');
        const showDeckBtn = document.getElementById('showDeckBtn');
        const generateDeckImageBtn = document.getElementById('generateDeckImageBtn'); // New button

        const searchCatalogInput = document.getElementById('searchCatalogInput');
        const colorFilterSelect = document.getElementById('colorFilterSelect');
        const cardTypeFilterSelect = document.getElementById('cardTypeFilterSelect');
        const costFilterSelect = document.getElementById('costFilterSelect');
        const buildRuleCheckbox = document.getElementById('buildRuleCheckbox');
        const buildRuleCheckboxLabel = document.getElementById('buildRuleCheckboxLabel'); // ラベルへの参照を追加
        const sortCriterionSelect = document.getElementById('sortCriterion');
        const sortDirectionBtn = document.getElementById('sortDirectionBtn');
        const toggleDisplayBtn = document.getElementById('toggleDisplayBtn');
        const catalogDisplayArea = document.getElementById('catalogDisplayArea');

        const leaderValidation = document.getElementById('leaderValidation');
        const currentLeaderCountSpan = document.getElementById('currentLeaderCount');
        const mainDeckSummary = document.getElementById('mainDeckSummary');
        const totalMainCardsSpan = document.getElementById('totalMainCards');
        const totalAceCardsSpan = document.getElementById('totalAceCards');
        const mainDeckValidation = document.getElementById('mainDeckValidation');
        const tacticsValidation = document.getElementById('tacticsValidation');
        const currentTacticsCountSpan = document.getElementById('currentTacticsCount');

        const deckNameInput = document.getElementById('deckNameInput');
        const deckDataTextarea = document.getElementById('deckDataTextarea');
        const exportDeckBtn = document.getElementById('exportDeckBtn');
        const copyExportedDataBtn = document.getElementById('copyExportedDataBtn');
        const importDeckBtn = document.getElementById('importDeckBtn');
        const importExportMessage = document.getElementById('importExportMessage');

        // New elements for export/import toggle
        const toggleExportImportBtn = document.getElementById('toggleExportImportBtn');
        const exportImportContent = document.getElementById('exportImportContent');


        // Modals
        const deckViewModal = document.getElementById('deckViewModal');
        const closeDeckViewModalBtn = document.getElementById('closeDeckViewModal');
        const modalDeckName = document.getElementById('modalDeckName');
        const modalLeaderCount = document.getElementById('modalLeaderCount');
        const modalMainCount = document.getElementById('modalMainCount');
        const modalTacticsCount = document.getElementById('modalTacticsCount');
        const modalAceCount = document.getElementById('modalAceCount');
        const modalLeaderCards = document.getElementById('modalLeaderCards');
        const modalMainCards = document.getElementById('modalMainCards');
        const modalTacticsCards = document.getElementById('modalTacticsCards');

        const cardDetailModal = document.getElementById('cardDetailModal');
        const closeCardDetailModalBtn = document.getElementById('closeCardDetailModal');
        const modalCardImage = document.getElementById('modalCardImage');
        const modalCardName = document.getElementById('modalCardName');
        const modalCardNumber = document.getElementById('modalCardNumber');
        const modalCardType = document.getElementById('modalCardType');
        const modalCardColor = document.getElementById('modalCardColor');
        const modalCardCost = document.getElementById('modalCardCost');
        const modalCardRarity = document.getElementById('modalCardRarity');
        const modalCardRules = document.getElementById('modalCardRules');
        const modalCardTag = document.getElementById('modalCardTag');
        const modalCardStats = document.getElementById('modalCardStats');
        const modalCardText = document.getElementById('modalCardText');

        const deckImageModal = document.getElementById('deckImageModal'); // New modal for deck image
        const closeDeckImageModalBtn = document.getElementById('closeDeckImageModal');
        const deckCanvas = document.getElementById('deckCanvas');
        const downloadDeckImageBtn = document.getElementById('downloadDeckImage');


        /**
         * CSVデータをパースしてカードデータを準備する
         * @param {string} csvText - CSV形式の文字列
         */
        function parseCSV(csvText) {
            const rawLines = csvText.split(/\r?\n/);
            const lines = [];
            let currentAccumulatedLine = '';
            let inQuote = false;

            for (let i = 0; i < rawLines.length; i++) {
                const line = rawLines[i];
                let tempInQuote = inQuote;

                for (let j = 0; j < line.length; j++) {
                    if (line[j] === '"') {
                        if (j + 1 < line.length && line[j+1] === '"') {
                            j++;
                        } else {
                            tempInQuote = !tempInQuote;
                        }
                    }
                }

                if (currentAccumulatedLine === '') {
                    currentAccumulatedLine = line;
                } else {
                    currentAccumulatedLine += '\n' + line;
                }

                if (!tempInQuote) {
                    lines.push(currentAccumulatedLine);
                    currentAccumulatedLine = '';
                    inQuote = false;
                } else {
                    inQuote = tempInQuote;
                }
            }

            if (currentAccumulatedLine !== '') {
                lines.push(currentAccumulatedLine);
            }
            
            if (lines.length === 0) {
                console.error("No content lines found in CSV after processing.");
                return;
            }
            const headers = lines[0].split(',').map(header => header.trim());

            allCardData = {};
            allCardDataByNumberPrefix = {};
            lines.slice(1).forEach((line, index) => {
                const values = parseCsvLine(line);
                let obj = {};
                
                if (values.length !== headers.length) {
                    console.warn(`Skipping logical line ${index + 2} due to column mismatch: "${line.substring(0, 100)}..." (Expected ${headers.length} columns, got ${values.length})`);
                    return;
                }

                headers.forEach((header, i) => {
                    obj[header] = values[i] ? values[i].trim() : '';
                });

                // Correct typo: "メモoriaカード" to "メモリアカード"
                if (obj['カード種類'] === 'メモoriaカード') {
                    obj['カード種類'] = 'メモリアカード';
                    console.warn(`Corrected typo: 'メモoriaカード' to 'メモリアカード' for card: ${obj['カード名']}`);
                }


                if (obj['カード名']) {
                    allCardData[obj['カード名']] = obj;
                    if (obj['カードナンバー']) {
                        const cardNumPrefix = obj['カードナンバー'].split('/')[0];
                        allCardDataByNumberPrefix[cardNumPrefix] = obj;
                    }
                } else {
                    console.warn(`Skipping logical line ${index + 2} with empty card name: "${line.substring(0, 100)}..."`);
                }
            });
            console.log('カードデータがロードされました:', Object.keys(allCardData).length, '枚');
        }

        function parseCsvLine(line) {
            const result = [];
            let inQuote = false;
            let currentField = '';
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuote && i + 1 < line.length && line[i+1] === '"') {
                        currentField += '"';
                        i++;
                    } else {
                        inQuote = !inQuote;
                    }
                } else if (char === ',' && !inQuote) {
                    result.push(currentField);
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            result.push(currentField);
            return result;
        }

        async function loadCardData() {
            loadingIndicator.classList.remove('hidden');
            const defaultCsvText = `採用,カード名,カードナンバー,カード種類,色,コスト,レアリティ,ビルドルール,タグ,覚醒前ATK,覚醒後ATK,覚醒前HP,覚醒後HP,ACE,サブタイプ,カードテキスト,収録,イラストレーター
,うるか,BP01-001/100 LR,リーダーカード,赤,,LR,,CR,30,40,100,130,,,【覚醒時】対戦相手のリーダーすべてに10ダメージ。,第1弾『Luminous Daybreak』,TSCR
,小森めと,BP01-002/100 LR,リーダーカード,赤,,LR,,VSPO!,30,40,100,130,,,【覚醒時】対戦相手のリーダー1体に20ダメージ。,第1弾『Luminous Daybreak』,株式会社アクアスター
,橘ひなの,BP01-003/100 LR,リーダーカード,赤,,LR,,VSPO!,30,40,110,140,,,【覚醒時】カードを2枚引き、手札を2枚捨てる。,第1弾『Luminous Daybreak』,株式会社アクアスター
,ふらんしすこ,BP01-004/100 LR,リーダーカード,赤,,LR,,CR,30,40,100,130,,,【覚醒時】カードを1枚引く。,第1弾『Luminous Daybreak』,TSCR
,Kamito,BP01-005/100 LR,リーダーカード,青,,LR,,,30,40,100,130,,,【覚醒時】カードを1枚引く。,第1弾『Luminous Daybreak』,mafuyu
,渋谷ハル,BP01-006/100 LR,リーダーカード,青,,LR,,Neo-Porte,30,40,100,130,,,【覚醒時】対戦相手のリーダーすべてに10ダメージ。,第1弾『Luminous Daybreak』,ケースワベ
,白雪レイド,BP01-007/100 LR,リーダーカード,青,,LR,,Neo-Porte,30,40,110,140,,,【覚醒時】カードを2枚引き、手札を2枚捨てる。,第1弾『Luminous Daybreak』,黎
,英リサ,BP01-008/100 LR,リーダーカード,青,,LR,,VSPO!,30,40,110,140,,,【覚醒時】自分のリーダー1体を20回復する。,第1弾『Luminous Daybreak』,株式会社アクアスター
,胡桃のあ,BP01-009/100 LR,リーダーカード,黄,,LR,,VSPO!,30,40,110,140,,,【覚醒時】自分のリーダー1体を20回復する。,第1弾『Luminous Daybreak』,株式会社アクアスター
,ごっちゃん,BP01-010/100 LR,リーダーカード,黄,,LR,,CR,30,40,110,140,,,【覚醒時】カードを2枚引き、手札を2枚捨てる。,第1弾『Luminous Daybreak』,TSCR
,兎咲ミミ,BP01-011/100 LR,リーダーカード,黄,,LR,,VSPO!,30,40,110,140,,,【覚醒時】対戦相手のリーダー1体に10ダメージ。,第1弾『Luminous Daybreak』,株式会社アクアスター
,VanilLa,BP01-012/100 LR,リーダーカード,黄,,LR,,CR,30,40,100,130,,,【覚醒時】カードを1枚引く。,第1弾『Luminous Daybreak』,TSCR
,空澄セナ,BP01-013/100 LR,リーダーカード,緑,,LR,,VSPO!,30,40,110,140,,,【覚醒時】カードを2枚引き、手札を2枚捨てる。,第1弾『Luminous Daybreak』,株式会社アクアスター
,ありさか,BP01-014/100 LR,リーダーカード,緑,,LR,,CR,30,40,100,130,,,【覚醒時】カードを1枚引く。,第1弾『Luminous Daybreak』,TSCR
,だるまいずごっど,BP01-015/100 LR,リーダーカード,緑,,LR,,CR,30,40,100,130,,,【覚醒時】対戦相手のリーダー1体に20ダメージ。,第1弾『Luminous Daybreak』,TSCR
,nqrse,BP01-016/100 LR,リーダーカード,緑,,LR,,,30,40,110,140,,,【覚醒時】対戦相手のリーダー1体に10ダメージ。,第1弾『Luminous Daybreak』,チョムチョム
,一騎当千,BP01-017/100 SR,アタックカード,赤,2,SR,,,,,,,ACE,,"【アタックする】\n【アタック後】自分の手札のエース以外のメモリアカードを、コストの合計が3以下になるように好きな枚数公開する。公開したカードを、コストを支払わず好きな順番でプレイする。（プレイしたカードは、このカードの右側に置く。それらの効果は、このアタックが終わってから左から順番に実行する。）",第1弾『Luminous Daybreak』,古弥月
,エレガントドミネート,BP01-018/100 C,アタックカード,赤,1,C,赤のリーダー3体以上,,,,,,,,"【アタックする】\n【アタック後】対戦相手の他のリーダー1体に20ダメージ。",第1弾『Luminous Daybreak』,MUGENUP
,インパクトショット,BP01-019/100 C,アタックカード,赤,2,C,,,,,,,,,【アタックする】ダメージ+40。,第1弾『Luminous Daybreak』,MUGENUP
,大黒柱,BP01-020/100 C,アタックカード,赤,1,C,リーダー：うるか,,,,,,,,【アタックする】手札を1枚捨ててもよい。そうしたならダメージ+20。,第1弾『Luminous Daybreak』,株式会社アクアスター
,ギャングの襲撃,BP01-021/100 UC,アタックカード,赤,1,UC,リーダー：小森めと,,,,,,,,"【アタックする】\n【アタック後】このアタックを受けたリーダーがダウンしているなら、カードを1枚引く。",第1弾『Luminous Daybreak』,Laara
,壁ジャンプ,BP01-022/100 R,アタックカード,赤,1,R,リーダー：Selly,,,,,,,,"プレイエリアに別の「壁ジャンプ」が1枚あるなら、コストを支払わずにこのカードをプレイしてもよい。（2枚以上あるときはコストを支払う。）\n\n【アタックする】",第1弾『Luminous Daybreak』,mono
,だまし討ち,BP01-023/100 R,アタックカード,赤,1,R,リーダー：橘ひなの,,,,,,,,【アタックする】ダメージ+10。,第1弾『Luminous Daybreak』,みたらしねこ
,ハイグラバースト,BP01-024/100 C,アタックカード,赤,1,C,リーダー：ふらんしすこ,,,,,,,,"【アタックする】\n【アタック後】プレイエリアにメモリアカードが2枚以上あるなら、対戦相手の他のリーダーすべてに10ダメージ。",第1弾『Luminous Daybreak』,株式会社アクアスター
,キリングスプリー,BP01-025/100 UC,アタックカード,赤,1,UC,リーダー：Mondo,,,,,,,,"【アタックする】\n【アタック後】このアタックを受けたリーダーがダウンしているなら、対戦相手の他のリーダー1体に20ダメージ。",第1弾『Luminous Daybreak』,MUGENUP
,CLUTCH!!!,BP01-026/100 SR,アタックカード,青,1,SR,,,,,,,ACE,,【アタックする】自分の手札のコスト0のカード1枚を公開し、捨ててもよい。そうしたならカードを1枚引き、ダメージ+40。,第1弾『Luminous Daybreak』,雨傘ゆん
,フラッシュバン,BP01-027/100 C,アタックカード,青,1,C,青のリーダー3体以上,,,,,,,,"【アタックする】\n【アタック後】対戦相手の他のリーダー1体に20ダメージ。",第1弾『Luminous Daybreak』,mns
,リスキーエントリー,BP01-028/100 C,アタックカード,青,1,C,,,,,,,,,"【アタックする】\n【アタック後】カードを1枚引き、手札を1枚捨てる。",第1弾『Luminous Daybreak』,green322
,うるパーンチッ,BP01-029/100 R,アタックカード,青,1,R,リーダー：一ノ瀬うるは,,,,,,,,"【アタックする】\n【アタック後】オーバーキル30：対戦相手の他のリーダー1体に50ダメージ。（このアタックを受けたリーダーに、そのリーダーの残り体力よりも30以上大きいダメージを与えていたなら、対戦相手の他のリーダー1体に50ダメージ。）",第1弾『Luminous Daybreak』,みきさい
,神速フリック,BP01-030/100 UC,アタックカード,青,1,UC,リーダー：Kamito,,,,,,,,【アタックする】対戦相手のデッキの上から1枚を公開し、トラッシュに置く。そのカードがアタックカードなら、ダメージ+20。,第1弾『Luminous Daybreak』,まよ
,勝利の一撃,BP01-031/100 C,アタックカード,青,1,C,リーダー：小雀とと,,,,,,,,"【アタックする】\n【アタック後】このアタックを受けたリーダーがダウンしているなら、カードを1枚引く。",第1弾『Luminous Daybreak』,株式会社アクアスター
,ドリル開錠,BP01-032/100 R,アタックカード,青,1,R,リーダー：渋谷ハル,,,,,,,,"【アタックする】\n【アタック後】すべてのプレイヤーは手札を1枚捨てる。",第1弾『Luminous Daybreak』,TAKOLEGS
,ブリッツブラスト,BP01-033/100 C,アタックカード,青,1,C,リーダー：白雪レイド,,,,,,,,"【アタックする】\n【アタック後】このアタックを受けたリーダーがダウンしているなら、対戦相手は手札を1枚捨てる。",第1弾『Luminous Daybreak』,株式会社アクアスター
,巧みな裏取り,BP01-034/100 UC,アタックカード,青,1,UC,リーダー：英リサ,,,,,,,,【アタックする】ダメージ+10。,第1弾『Luminous Daybreak』,明日倉
,ロケットランチャー,BP01-035/100 SR,アタックカード,黄,2,SR,,,,,,,ACE,,"【アタックする】ダメージ+40。\n【アタック後】対戦相手の他のリーダー1体に30ダメージ。",第1弾『Luminous Daybreak』,Kawa
,カウンタースナイプ,BP01-036/100 C,アタックカード,黄,1,C,,,,,,,,,"【アタックする】\n【アタック後】自分の手札が2枚以下なら、対戦相手の他のリーダー1体に20ダメージ。",第1弾『Luminous Daybreak』,四鈴あざな
,ヴェノムスモーク,BP01-037/100 C,アタックカード,黄,1,C,黄のリーダー3体以上,,,,,,,,"【アタックする】\n【アタック後】対戦相手の他のリーダーすべてに10ダメージ。",第1弾『Luminous Daybreak』,mns
,クラッチクイーン,BP01-038/100 C,アタックカード,黄,1,C,リーダー：胡桃のあ,,,,,,,,【アタックする】ダメージ+10。,第1弾『Luminous Daybreak』,株式会社アクアスター
,アジト急襲,BP01-039/100 C,アタックカード,黄,1,C,リーダー：ごっちゃん@マイキー,,,,,,,,"【アタックする】\n【アタック後】オーバーキル30：PPを1回復する。（このアタックを受けたリーダーに、そのリーダーの残り体力よりも30以上大きいダメージを与えていたなら、PPを1回復する。）",第1弾『Luminous Daybreak』,株式会社アクアスター
,Lastman Standing,BP01-040/100 R,アタックカード,黄,1,R,リーダー：Cpt,,,,,,,,【アタックする】手札を1枚捨ててもよい。そうしたならダメージ+20。,第1弾『Luminous Daybreak』,ｩﾄﾞﾝ!!!
,固定砲台みみたや,BP01-041/100 UC,アタックカード,黄,1,UC,リーダー：兎咲ミミ,,,,,,,,"【アタックする】\n【アタック後】このアタックを受けたリーダーがダウンしているなら、対戦相手の他のリーダー1体に20ダメージ。",第1弾『Luminous Daybreak』,ミョワ
,ウォールブレイカー,BP01-042/100 UC,アタックカード,黄,1,UC,リーダー：VanilLa,,,,,,,,"【アタックする】\n【アタック後】プレイエリアにメモリアカードが2枚以上あるなら、対戦相手の他のリーダー1体に20ダメージ。",第1弾『Luminous Daybreak』,倉林
,ブービートラップ,BP01-043/100 R,アタックカード,黄,1,R,リーダー：Ras,,,,,,,,"【アタックする】\n【アタック後】このアタックを受けたリーダーがダウンしているなら、カードを1枚引く。",第1弾『Luminous Daybreak』,春夏
,リンク•アサルト,BP01-044/100 SR,アタックカード,緑,1,SR,,,,,,,ACE,,"【アタックする】\n【アタック後】自分のデッキの上から3枚を見る。その中からコスト1以下のメモリアカード1枚を、コストを支払わずにプレイしてもよい。残りのカードをトラッシュに置く。（プレイしたカードの効果は、このアタックが終わってから実行する。）",第1弾『Luminous Daybreak』,くるみつ
,クレイジーバースト,BP01-045/100 C,アタックカード,緑,1,C,緑のリーダー3体以上,,,,,,,,"【アタックする】\n【アタック後】対戦相手の他のリーダーすべてに10ダメージ。",第1弾『Luminous Daybreak』,green322
,クリティカルショット,BP01-046/100 C,アタックカード,緑,3,C,,,,,,,,,【アタックする】ダメージ+70。,第1弾『Luminous Daybreak』,mns
,いたずらドローン,BP01-047/100 R,アタックカード,緑,1,R,リーダー：空澄セナ,,,,,,,,"【アタックする】\n【アタック後】プレイエリアにメモリアカードが2枚以上あるなら、対戦相手の他のリーダー1体に20ダメージ。",第1弾『Luminous Daybreak』,てんてこ
,スリフティプレイ,BP01-048/100 UC,アタックカード,緑,0,UC,リーダー：ありさか,,,,,,,,【アタックする】ダメージ-20。,第1弾『Luminous Daybreak』,株式会社アクアスター
,冷静沈着,BP01-049/100 UC,アタックカード,緑,1,UC,リーダー：花芽すみれ,,,,,,,,【アタックする】ダメージ+10。,第1弾『Luminous Daybreak』,猫山 桜梨
,ブラインドショット,BP01-050/100 C,アタックカード,緑,1,C,リーダー：花芽なずな,,,,,,,,"【アタックする】\n【アタック後】プレイエリアにメモリアカードが2枚以上あるなら、対戦相手の他のリーダーすべてに10ダメージ。",第1弾『Luminous Daybreak』,株式会社アクアスター
,コンビネーションアタック,BP01-051/100 R,アタックカード,緑,1,R,リーダー：だるまいずごっど,,,,,,,,"【アタックする】\n【アタック後】このアタックを受けたリーダーがダウンしているなら、カードを1枚引く。",第1弾『Luminous Daybreak』,ikuyoan
,スタンプキル,BP01-052/100 C,アタックカード,緑,1,C,リーダー：nqrse,,,,,,,,"【アタックする】\n【アタック後】オーバーキル30：PPを1回復する。（このアタックを受けたリーダーに、そのリーダーの残り体力よりも30以上大きいダメージを与えていたなら、PPを1回復する。）",第1弾『Luminous Daybreak』,株式会社アクアスター
,超新星,BP01-053/100 SR,メモリアカード,赤,2,SR,,,,,,,,,"【アタック強化】次のアタックのダメージ+30。\n【アタック後】このアタックを受けたリーダーがダウンしているなら、PPを2回復し、カードを1枚引く。",第1弾『Luminous Daybreak』,からながれ
,胴だよ胴!,BP01-054/100 C,メモリアカード,赤,1,C,,,,,,,,,【アタック強化】次のアタックのダメージ+50。,第1弾『Luminous Daybreak』,蟹由
,偉大な栄冠,BP01-055/100 C,メモリアカード,赤,2,C,,,,,,,,,【アタック強化】次のアタックのダメージ+80。,第1弾『Luminous Daybreak』,MUGENUP
,何も知らない,BP01-056/100 C,メモリアカード,赤,0,C,リーダー：うるか,,,,,,,,【アタック強化】プレイエリアにメモリアカードが3枚以上あるなら、次のアタックのダメージ+30。（メモリアカードの数は【アタック強化】を実行するときに数える。）,第1弾『Luminous Daybreak』,MUGENUP
,新たなる場所へ,BP01-057/100 R,メモリアカード,赤,1,R,リーダー：小森めと,,,,,,,,"【アタック強化】次のアタックのダメージ+30。\n【アタック後】対戦相手の他のリーダーすべてに10ダメージ。",第1弾『Luminous Daybreak』,あすぱら
,危機一髪,BP01-058/100 UC,メモリアカード,赤,1,UC,リーダー：Selly,,,,,,,,【プレイ時】カードを2枚引く。,第1弾『Luminous Daybreak』,MUGENUP
,笑ってはいけない,BP01-059/100 C,メモリアカード,赤,1,C,リーダー：橘ひなの,,,,,,,,【アタック強化】次のアタックのダメージ+60。,第1弾『Luminous Daybreak』,蟹由
,副音声,BP01-060/100 UC,メモリアカード,赤,1,UC,リーダー：ふらんしすこ,,,,,,,,"【プレイ時】カードを1枚引く。\n【アタック強化】次のアタックのダメージ+30。",第1弾『Luminous Daybreak』,そとま
,逃走成功,BP01-061/100 R,メモリアカード,赤,1,R,リーダー：Mondo,,,,,,,,"【プレイ時】すべてのプレイヤーはカードを1枚引く。\n【アタック強化】次のアタックのダメージ+50。",第1弾『Luminous Daybreak』,桑島黎音
,Never Fall,BP01-062/100 SR,メモリアカード,青,1,SR,,,,,,,ACE,,【プレイ時】カードを3枚引く。,第1弾『Luminous Daybreak』,ran9u
,苦難の昇格,BP01-063/100 C,メモリアカード,青,1,C,,,,,,,,,"【プレイ時】カードを2枚引き、手札を2枚捨てる。\n【アタック強化】次のアタックのダメージ+30。",第1弾『Luminous Daybreak』,mowa
,ゾーン状態,BP01-064/100 C,メモリアカード,青,2,C,,,,,,,,,【アタック強化】次のアタックのダメージ+80。,第1弾『Luminous Daybreak』,MUGENUP
,汚部屋の住人,BP01-065/100 C,メモリアカード,青,1,C,リーダー：一ノ瀬うるは,,,,,,,,【アタック強化】次のアタックのダメージ+60。,第1弾『Luminous Daybreak』,葉かま
,博聞強記,BP01-066/100 UC,メモリアカード,青,1,UC,リーダー：Kamito,,,,,,,,"【プレイ時】カードを1枚引く。\n【アタック強化】次のアタックのダメージ+30。",第1弾『Luminous Daybreak』,ゆーり
,いつも安全運転,BP01-067/100 R,メモリアカード,青,1,R,リーダー：小雀とと,,,,,,,,【プレイ時】カードを2枚引く。,第1弾『Luminous Daybreak』,ハナモト
,運命のルーレット,BP01-068/100 C,メモリアカード,青,1,C,リーダー：渋谷ハル,,,,,,,,【プレイ時】メモリアカードかアタックカードのどちらかを宣言し、自分のデッキの上から1枚を公開する。そのカードが宣言したカードタイプならカードを4枚引く。それ以外なら公開したカードをトラッシュに置く。,第1弾『Luminous Daybreak』,はにわ
,運もミスもない,BP01-069/100 R,メモリアカード,青,0,R,リーダー：白雪レイド,,,,,,,,"【プレイ時】自分のデッキの上から1枚を見る。そのカードをトラッシュに置いてもよい。\n【アタック強化】次のアタックのダメージ+10。",第1弾『Luminous Daybreak』,さんかく。
,BEAUTY SALON -HANABUSA-,BP01-070/100 UC,メモリアカード,青,0,UC,リーダー：英リサ,,,,,,,,【プレイ時】対戦相手のリーダー1体に20ダメージ。,第1弾『Luminous Daybreak』,memeno
,先導者の証,BP01-071/100 SR,メモリアカード,黄,1,SR,,,,,,,ACE,,【プレイ時】このターン、自分のリーダーすべての攻撃力を+30する。,第1弾『Luminous Daybreak』,じゃむ
,花火づくり,BP01-072/100 C,メモリアカード,黄,1,C,,,,,,,,,"【プレイ時】カードを2枚引き、手札を2枚捨てる。\n【アタック強化】次のアタックのダメージ+30。",第1弾『Luminous Daybreak』,はにわ
,福男,BP01-073/100 C,メモリアカード,黄,1,C,,,,,,,,,"【プレイ時】自分のリーダーが3体ダウンしているなら、カードを1枚引く。\n【アタック強化】次のアタックのダメージ+40。",第1弾『Luminous Daybreak』,倉林
,来てくれてありがとう,BP01-074/100 R,メモリアカード,黄,1,R,リーダー：胡桃のあ,,,,,,,,【プレイ時】カードを2枚引く。,第1弾『Luminous Daybreak』,ほたてんし
,開店セレモニー,BP01-075/100 R,メモリアカード,黄,1,R,リーダー：ごっちゃん@マイキー,,,,,,,,【アタック強化】次のアタックのダメージ+20。プレイエリアにメモリアカードが3枚以上あるなら、さらにダメージ+50。（メモリアカードの数は【アタック強化】を実行するときに数える。）,第1弾『Luminous Daybreak』,高山しのぶ
,優勝請負人,BP01-076/100 UC,メモリアカード,黄,1,UC,リーダー：Cpt,,,,,,,,【アタック強化】次のアタックのダメージ+60。,第1弾『Luminous Daybreak』,MUGENUP
,777,BP01-077/100 C,メモリアカード,黄,0,C,リーダー：兎咲ミミ,,,,,,,,【アタック強化】プレイエリアにメモリアカードが3枚以上あるなら、次のアタックのダメージ+30。（メモリアカードの数は【アタック強化】を実行するときに数える。）,第1弾『Luminous Daybreak』,ふつー
,偶然の邂逅,BP01-078/100 UC,メモリアカード,黄,1,UC,リーダー：VanilLa,,,,,,,,"【アタック強化】次のアタックのダメージ+30。\n【アタック後】対戦相手の他のリーダーすべてに10ダメージ。",第1弾『Luminous Daybreak』,白菜ポンズ
,小さなビデオレター,BP01-079/100 C,メモリアカード,黄,1,C,リーダー：Ras,,,,,,,,"【アタック強化】次のアタックのダメージ+50。\n【アタック後】対戦相手の他のリーダー1体に10ダメージ。",第1弾『Luminous Daybreak』,mns
,勝利へのジャンプ,BP01-080/100 SR,メモリアカード,緑,3,SR,,,,,,,ACE,,【プレイ時】対戦相手のリーダーすべてに50ダメージ。,第1弾『Luminous Daybreak』,ドルストイ
,喧嘩上等,BP01-081/100 C,メモリアカード,緑,1,C,,,,,,,,,【アタック強化】次のアタックのダメージ+50。,第1弾『Luminous Daybreak』,倉林
,登頂成功,BP01-082/100 C,メモリアカード,緑,1,C,,,,,,,,,"【プレイ時】自分のリーダーが3体ダウンしているなら、カードを1枚引く。\n【アタック強化】次のアタックのダメージ+40。",第1弾『Luminous Daybreak』,明日倉
,バトンを繋いで,BP01-083/100 C,メモリアカード,緑,1,C,リーダー：空澄セナ,,,,,,,,【アタック強化】次のアタックのダメージ+60。,第1弾『Luminous Daybreak』,motto
,引っ張り合い,BP01-084/100 UC,メモリアカード,緑,1,UC,リーダー：ありさか,,,,,,,,"プレイエリアに別の「引っ張り合い」が1枚あるなら、コストを支払わずにこのカードをプレイしてもよい。（2枚以上あるときはコストを支払う。）\n\n【アタック強化】次のアタックのダメージ+40。",第1弾『Luminous Daybreak』,MUGENUP
,風紀チェック,BP01-085/100 R,メモリアカード,緑,1,R,リーダー：花芽すみれ,,,,,,,,"【アタック強化】次のアタックのダメージ+50。\n【アタック後】対戦相手の他のリーダー1体に10ダメージ。",第1弾『Luminous Daybreak』,やもり四季。
,なずNEWS,BP01-086/100 R,メモリアカード,緑,1,R,リーダー：花芽なずな,,,,,,,,【プレイ時】カードを2枚引く。,第1弾『Luminous Daybreak』,街子まき
,丸太椅子最,BP01-087/100 C,メモリアカード,緑,0,C,リーダー：だるまいずごっど,,,,,,,,【プレイ時】対戦相手のリーダー1体に20ダメージ。,第1弾『Luminous Daybreak』,倉林
,モラルからのハミダシ,BP01-088/100 UC,メモリアカード,緑,1,UC,リーダー：nqrse,,,,,,,,"【プレイ時】すべてのプレイヤーはカードを1枚引く。\n【アタック強化】次のアタックのダメージ+50。",第1弾『Luminous Daybreak』,アラタ
,アドレナリン,BP01-089/100 TR,タクティクスカード,無,0,TR,,,,,,,,消費,"【プレイ時】カードを1枚引く。\n【アタック強化】次のアタックのダメージ+40。",第1弾『Luminous Daybreak』,SyunsukeYasumura
,エナジーチャージャー,BP01-090/100 TR,タクティクスカード,無,0,TR,,,,,,,,消費,【プレイ時】PPを1回復し、カードを1枚引く。,第1弾『Luminous Daybreak』,HayatoKitazaki
,救急キット,BP01-091/100 TR,タクティクスカード,無,0,TR,,,,,,,,消費,【プレイ時】自分のリーダーを合計80回復する。（複数のリーダーを選んでもよい。）,第1弾『Luminous Daybreak』,HayatoKitazaki
,ストラテジックレーダー,BP01-092/100 TR,タクティクスカード,無,0,TR,,,,,,,,消費,【プレイ時】カードを2枚引く。,第1弾『Luminous Daybreak』,HayatoKitazaki
,ジャミングパルス,BP01-093/100 TR,タクティクスカード,無,1,TR,,,,,,,,消費,【プレイ時】対戦相手は手札を2枚捨てる。,第1弾『Luminous Daybreak』,HayatoKitazaki
,復活ポータル,BP01-094/100 TR,タクティクスカード,無,2,TR,,,,,,,,消費,"このカードは、対戦相手よりダウンしているリーダーが多いなら、プレイできる。\n\n【プレイ時】ダウンしている自分のリーダー1体を、ダウンしていない状態に戻す。そのリーダーが装備しているカードすべてを表向きにトラッシュに置く。",第1弾『Luminous Daybreak』,HayatoKitazaki
,ライトシールド,BP01-095/100 TR,タクティクスカード,無,0,TR,,,,,,,,装備,体力+30,第1弾『Luminous Daybreak』,HayatoKitazaki
,ボディアーマー,BP01-096/100 TR,タクティクスカード,無,2,TR,,,,,,,,装備,体力+40,第1弾『Luminous Daybreak』,HayatoKitazaki
,PPチケット,BP01-097/100 TR,タクティクスカード,無,0,TR,,,,,,,,消費,"このカードをタクティクスデッキに入れることはできない。\n1ラウンド目のタクティクスカードを選択した後、後攻のプレイヤーはこのカードをタクティクスエリアに置く。\n\n【プレイ時】PPを1回復する。",第1弾『Luminous Daybreak』,SyunsukeYasumura
,一ノ瀬うるは,ST01-001/025 LR,リーダーカード,青,,LR,,VSPO!,30,40,100,130,,,【覚醒時】カードを1枚引く。,スターターデッキ『初の栄冠』カードナンバーST01-001/025 LR,
,小雀とと,ST01-002/025 LR,リーダーカード,青,,LR,,VSPO!,30,40,110,140,,,【覚醒時】対戦相手のリーダー1体に10ダメージ。,スターターデッキ『初の栄冠』カードナンバーST01-002/025 LR,
,花芽すみれ,ST01-003/025 LR,リーダーカード,緑,,LR,,VSPO!,30,40,100,130,,,【覚醒時】対戦相手のリーダーすべてに10ダメージ。,スターターデッキ『初の栄栄冠』カードナンバーST01-003/025 LR,
,花芽なずな,ST01-004/025 LR,リーダーカード,緑,,LR,,VSPO!,30,40,110,140,,,【覚醒時】自分のリーダー1体を20回復する。,スターターデッキ『初の栄冠』カードナンバーST01-004/025 LR,
,クロスファイア,ST01-005/025 SR,アタックカード,青,3,SR,,,,,,,ACE,,【アタックする】自分のリーダーすべてが「VSPO!」を持つなら、このアタックを受けたリーダーはダウンする。,スターターデッキ『初の栄冠』カードナンバーST01-005/025 SR,
,リスキーエントリー,ST01-006/025 C,アタックカード,青,1,C,,,,,,,,,"【アタックする】\n【アタック後】カードを1枚引き、手札を1枚捨てる。",スターターデッキ『初の栄冠』カードナンバーST01-006/025 C,
,バウンティーハンター,ST01-007/025 C,アタックカード,青,2,C,,,,,,,,,"【アタックする】\n【アタック後】対戦相手の他のリーダー1体に40ダメージ。",スターターデッキ『初の栄冠』カードナンバーST01-007/025 C,
,勝利の一撃,ST01-008/025 C,アタックカード,青,1,C,リーダー：小雀とと,,,,,,,,"【アタックする】\n【アタック後】このアタックを受けたリーダーがダウンしているなら、カードを1枚引く。",スターターデッキ『初の栄冠』カードナンバーST01-008/025 C,
,強さの証明,ST01-009/025 C,アタックカード,緑,1,C,,,,,,,,,"【アタックする】\n【アタック後】対戦相手の他のリーダー1体に10ダメージ。",スターターデッキ『初の栄冠』カードナンバーST01-009/025 C,
,クリティカルショット,ST01-010/025 C,アタックカード,緑,3,C,,,,,,,,,【アタックする】ダメージ+70。,スターターデッキ『初の栄冠』カードナンバーST01-010/025 C,
,冷静沈着,ST01-011/025 UC,アタックカード,緑,1,UC,リーダー：花芽すみれ,,,,,,,,【アタックする】ダメージ+10。,スターターデッキ『初の栄冠』カードナンバーST01-011/025 UC,
,ブラインドショット,ST01-012/025 C,アタックカード,緑,1,C,リーダー：花芽なずな,,,,,,,,"【アタックする】\n【アタック後】プレイエリアにメモリアカードが2枚以上あるなら、対戦相手の他のリーダーすべてに10ダメージ。",スターターデッキ『初の栄冠』カードナンバーST01-012/025 C,
,駆け引き上手,ST01-013/025 C,メモリアカード,青,1,C,,,,,,,,,【アタック強化】次のアタックのダメージ+50。,スターターデッキ『初の栄冠』カードナンバーST01-013/025 C,
,ゾーン状態,ST01-014/025 C,メモリアカード,青,2,C,,,,,,,,,【アタック強化】次のアタックのダメージ+80。,スターターデッキ『初の栄冠』カードナンバーST01-014/025 C,
,汚部屋の住人,ST01-015/025 C,メモリアカード,青,1,C,リーダー：一ノ瀬うるは,,,,,,,,【アタック強化】次のアタックのダメージ+60。,スターターデッキ『初の栄冠』カードナンバーST01-015/025 C,
,初の栄冠,ST01-016/025 SR,メモリアカード,緑,1,SR,,,,,,,ACE,,"【アタック強化】次のアタックのダメージ+30。\n【アタック後】対戦相手の他のリーダー1体に、自分の「VSPO!」を持つリーダー1体につき10ダメージ。",スターターデッキ『初の栄冠』カードナンバーST01-016/025 SR,
,登頂成功,ST01-017/025 C,メモリアカード,緑,1,C,,,,,,,,,"【プレイ時】自分のリーダーが3体ダウンしているなら、カードを1枚引く。\n【アタック強化】次のアタックのダメージ+40。",スターターデッキ『初の栄冠』カードナンバーST01-017/025 C,
,面接官,ST01-018/025 C,メモリアカード,緑,1,C,,,,,,,,,"【プレイ時】自分のリーダー1体を30回復する。\n【アタック強化】次のアタックのダメージ+30。",スターターデッキ『初の栄冠』カードナンバーST01-018/025 C,
,Selly,ST02-001/025 LR,リーダーカード,赤,,LR,,CR,30,40,110,140,,,【覚醒時】対戦相手のリーダー1体に10ダメージ。,スターターデッキ『魔王降臨』カードナンバーST02-001/025 LR,
,Mondo,ST02-002/025 LR,リーダーカード,赤,,LR,,CR,30,40,110,140,,,【覚醒時】自分のリーダー1体を20回復する。,スターターデッキ『魔王降臨』カードナンバーST02-002/025 LR,
,Cpt,ST02-003/025 LR,リーダーカード,黄,,LR,,CR,30,40,100,130,,,【覚醒時】カードを1枚引く。,スターターデッキ『魔王降臨』カードナンバーST02-003/025 LR,
,Ras,ST02-004/025 LR,リーダーカード,黄,,LR,,CR,30,40,100,130,,,【覚醒時】対戦相手のリーダーすべてに10ダメージ。,スターターデッキ『魔王降臨』カードナンバーST02-004/025 LR,
,異次元キック,ST02-005/025 C,アタックカード,赤,1,C,,,,,,,,,"【アタックする】\n【アタック後】対戦相手の他のリーダー1体に10ダメージ。",スターターデッキ『魔王降臨』カードナンバーST02-005/025 C,
,過激ないたずら,ST02-006/025 C,アタックカード,赤,1,C,,,,,,,,,"【アタックする】\n【アタック後】カードを1枚引き、手札を1枚捨てる。",スターターデッキ『魔王降臨』カードナンバーST02-006/025 C,
,インパクトショット,ST02-007/025 C,アタックカード,赤,2,C,,,,,,,,,【アタックする】ダメージ+40。,スターターデッキ『魔王降臨』カードナンバーST02-007/025 C,
,キリングスプリー,ST02-008/025 UC,アタックカード,赤,1,UC,リーダー：Mondo,,,,,,,,"【アタックする】\n【アタック後】このアタックを受けたリーダーがダウンしているなら、対戦相手の他のリーダー1体に20ダメージ。",スターターデッキ『魔王降臨』カードナンバーST02-008/025 UC,
,魔王降臨,ST02-009/025 SR,アタックカード,黄,3,SR,,,,,,,ACE,,【アタックする】自分のリーダーすべてが「CR」を持つなら、このアタックを受けたリーダーはダウンする。,スターターデッキ『魔王降臨』カードナンバーST02-009/025 SR,
,カウンタースナイプ,ST02-010/025 C,アタックカード,黄,1,C,,,,,,,,,"【アタックする】\n【アタック後】自分の手札が2枚以下なら、対戦相手の他のリーダー1体に20ダメージ。",スターターデッキ『魔王降臨』カードナンバーST02-010/025 C,
,マルチグレネード,ST02-011/025 C,アタックカード,黄,2,C,,,,,,,,,"【アタックする】\n【アタック後】対戦相手の他のリーダーすべてに20ダメージ。",スターターデッキ『魔王降臨』カードナンバーST02-011/025 C,
,変わらない関係,ST02-012/025 SR,メモリアカード,赤,1,SR,,,,,,,ACE,,"【アタック強化】次のアタックのダメージ+30。\n【アタック後】対戦相手の他のリーダー1体に、自分の「CR」を持つリーダー1体につき10ダメージ。",スターターデッキ『魔王降臨』カードナンバーST02-012/025 SR,
,偉大な栄冠,ST02-013/025 C,メモリアカード,赤,2,C,,,,,,,,,【アタック強化】次のアタックのダメージ+80。,スターターデッキ『魔王降臨』カードナンバーST02-013/025 C,
,危機一髪,ST02-014/025 UC,メモリアカード,赤,1,UC,リーダー：Selly,,,,,,,,【プレイ時】カードを2枚引く。,スターターデッキ『魔王降臨』カードナンバーST02-014/025 UC,
,ツアーガイド,ST02-015/025 C,メモリアカード,黄,1,C,,,,,,,,,【アタック強化】次のアタックのダメージ+50。,スターターデッキ『魔王降臨』カードナンバーST02-015/025 C,
,福男,ST02-016/025 C,メモリアカード,黄,1,C,,,,,,,,,"【プレイ時】自分のリーダーが3体ダウンしているなら、カードを1枚引く。\n【アタック強化】次のアタックのダメージ+40。",スターターデッキ『魔王降臨』カードナンバーST02-016/025 C,
,優勝請負人,ST02-017/025 UC,メモリアカード,黄,1,UC,リーダー：Cpt,,,,,,,,【アタック強化】次のアタックのダメージ+60。,スターターデッキ『魔王降臨』カードナンバーST02-017/025 UC,
,小さなビデオレター,ST02-018/025 C,メモリアカード,黄,1,C,リーダー：Ras,,,,,,,,"【アタック強化】次のアタックのダメージ+50。\n【アタック後】対戦相手の他のリーダー1体に10ダメージ。",スターターデッキ『魔王降臨』カードナンバーST02-018/025 C,
`;
            
            parseCSV(defaultCsvText);
            loadingIndicator.classList.add('hidden');
            // Initial render
            renderCatalog();
            updateFilterAndSortUI(); // Initial filter/sort UI update
        }

        function parseCsvLine(line) {
            const result = [];
            let inQuote = false;
            let currentField = '';
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuote && i + 1 < line.length && line[i+1] === '"') {
                        currentField += '"';
                        i++;
                    } else {
                        inQuote = !inQuote;
                    }
                } else if (char === ',' && !inQuote) {
                    result.push(currentField);
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            result.push(currentField);
            return result;
        }

        /**
         * カード画像URLを生成するヘルパー関数
         * @param {Object} cardInfo - カードの全情報を持つオブジェクト
         * @returns {string} 画像URLまたはプレースホルダーURL
         */
        function getCardImageUrl(cardInfo) {
            if (!cardInfo || !cardInfo['カードナンバー'] || !cardInfo['カード種類']) {
                console.warn("Missing card info for image URL generation:", cardInfo);
                return 'https://placehold.co/150x210/cccccc/333333?text=No+Image'; // Fallback for incomplete data
            }

            const cardNumPrefix = cardInfo['カードナンバー'].split('/')[0];
            let cardTypeFolder;

            switch (cardInfo['カード種類']) {
                case 'リーダーカード':
                    cardTypeFolder = 'LEADER';
                    break;
                case 'アタックカード':
                    cardTypeFolder = 'ATTACK';
                    break;
                case 'メモリアカード':
                    cardTypeFolder = 'MEMORIA';
                    break;
                case 'タクティクスカード':
                    cardTypeFolder = 'TACTICS';
                    break;
                default:
                    console.warn("Unknown card type for image URL:", cardInfo['カード種類']);
                    return `https://placehold.co/150x210/cccccc/333333?text=Unknown+Type\\n${cardNumPrefix}`; // Fallback for unknown types
            }

            return `https://xrossstars-info.com/deckbuilder/card/${cardTypeFolder}/${cardNumPrefix}.jpg`;
        }


        /**
         * デッキの表示を更新し、バリデーションを実行する
         */
        function updateDeckDisplay() {
            // バリデーションの更新
            validateDeck();
            // 現在のカタログ表示を更新 (枚数表示などが変わるため)
            renderCatalog();
            // デッキ表示モーダルが開いている場合は、その内容も更新
            if (!deckViewModal.classList.contains('hidden')) {
                showDeckViewModal();
            }
        }

        /**
         * デッキ構築ルールに基づいてバリデーションを実行し、メッセージを更新する
         */
        function validateDeck() {
            // リーダーデッキのバリデーション
            if (leaderDeck.length === 4) {
                leaderValidation.className = 'validation-message validation-success';
                leaderValidation.textContent = 'リーダーカード: OK (4/4枚)';
            } else if (leaderDeck.length < 4) {
                leaderValidation.className = 'validation-message validation-warning';
                leaderValidation.textContent = `リーダーカードが不足しています: ${leaderDeck.length}/4 枚`;
            } else {
                leaderValidation.className = 'validation-message validation-error';
                leaderValidation.textContent = `リーダーカードが多すぎます: ${leaderDeck.length}/4 枚`;
            }
            currentLeaderCountSpan.textContent = leaderDeck.length;

            // メインデッキのバリデーション
            let totalMainCards = 0;
            let totalAceCards = 0;
            const cardCounts = {}; // 同名カードの枚数をカウント

            mainDeck.forEach(card => {
                totalMainCards += card.quantity;
                if (card.isAce) {
                    totalAceCards += card.quantity;
                }
                cardCounts[card.name] = (cardCounts[card.name] || 0) + card.quantity;
            });

            totalMainCardsSpan.textContent = totalMainCards;
            totalAceCardsSpan.textContent = totalAceCards;

            let mainDeckValidationMessages = [];
            let isMainDeckValid = true;

            if (totalMainCards === 50) {
                mainDeckValidationMessages.push('合計カード数: OK (50/50枚)');
            } else if (totalMainCards < 50) {
                mainDeckValidationMessages.push(`合計カード数が不足しています: ${totalMainCards}/50 枚`);
                isMainDeckValid = false;
            } else {
                mainDeckValidationMessages.push(`合計カード数が多すぎます: ${totalMainCards}/50 枚`);
                isMainDeckValid = false;
            }

            if (totalAceCards <= 8) {
                mainDeckValidationMessages.push(`エースカード数: OK (${totalAceCards}/8枚)`);
            } else {
                mainDeckValidationMessages.push(`エースカードが多すぎます: ${totalAceCards}/8 枚`);
                isMainDeckValid = false;
            }

            for (const cardName in cardCounts) {
                if (cardCounts[cardName] > 4) {
                    mainDeckValidationMessages.push(`同名カードが多すぎます (${cardName}): ${cardCounts[cardName]}/4 枚`);
                    isMainDeckValid = false;
                }
            }

            if (isMainDeckValid && totalMainCards === 50 && totalAceCards <= 8 && Object.values(cardCounts).every(count => count <= 4)) {
                mainDeckValidation.className = 'validation-message validation-success';
                mainDeckValidation.textContent = 'メインデッキ: OK';
            } else {
                mainDeckValidation.className = 'validation-message validation-error';
                if (mainDeckValidationMessages.length === 0) {
                     mainDeckValidation.textContent = 'メインデッキの枚数とルールの確認。';
                } else {
                    mainDeckValidation.innerHTML = mainDeckValidationMessages.join('<br>');
                }
            }

            // タクティクスデッキのバリデーション
            if (tacticsDeck.length === 5) {
                tacticsValidation.className = 'validation-message validation-success';
                tacticsValidation.textContent = 'タクティクスカード: OK (5/5枚)';
            } else if (tacticsDeck.length < 5) {
                tacticsValidation.className = 'validation-message validation-warning';
                tacticsValidation.textContent = `タクティクスカードが不足しています: ${tacticsDeck.length}/5 枚`;
            } else {
                tacticsValidation.className = 'validation-message validation-error';
                tacticsValidation.textContent = `タクティクスカードが多すぎます: ${tacticsDeck.length}/5 枚`;
            }
            currentTacticsCountSpan.textContent = tacticsDeck.length;

            // 各バリデーションの状態を返す
            return {
                isLeaderValid: leaderDeck.length === 4,
                isMainValid: isMainDeckValid && totalMainCards === 50 && totalAceCards <= 8 && Object.values(cardCounts).every(count => count <= 4),
                isTacticsValid: tacticsDeck.length === 5
            };
        }

        /**
         * カードを適切なデッキに追加する共通関数
         * @param {string} cardName - 追加するカードの名前
         * @param {number} quantity - 追加する枚数
         * @param {('leader'|'main'|'tactics')} targetDeckType - ターゲットとなるデッキの種類
         */
        function addCardToDeck(cardName, quantity, targetDeckType) {
            const cardInfo = allCardData[cardName];

            if (!cardName || !cardInfo) {
                alert('カード情報が見つかりません。');
                return;
            }

            // デッキタイプに応じたルールチェック
            if (targetDeckType === 'leader') {
                if (cardInfo['カード種類'] !== 'リーダーカード') {
                    alert('このカードはリーダーカードではありません。');
                    return;
                }
                if (leaderDeck.length >= 4) {
                    alert('リーダーカードは4枚までです。');
                    return;
                }
                if (leaderDeck.some(card => card.name === cardName)) {
                    alert('このリーダーカードはすでにデッキに存在します。');
                    return;
                }
                leaderDeck.push({ name: cardName, cardData: cardInfo });
            } else if (targetDeckType === 'main') {
                if (cardInfo['カード種類'] === 'リーダーカード' || cardInfo['カード種類'] === 'タクティクスカード') {
                    alert('このカードはメインデッキには追加できません。');
                    return;
                }
                if (quantity < 1 || quantity > 4) { // Quantity check for single card add
                    alert('追加する枚数は1から4の間で指定してください。');
                    return;
                }

                const isAce = cardInfo['ACE'] === 'ACE' || cardInfo['ACE'] === 'エース';
                let totalCurrentMainCards = mainDeck.reduce((sum, card) => sum + card.quantity, 0);

                const existingCardIndex = mainDeck.findIndex(card => card.name === cardName);
                if (existingCardIndex > -1) {
                    const currentCount = mainDeck[existingCardIndex].quantity;
                    if (currentCount + quantity > 4) {
                        alert(`同名カードは4枚までです。現在${currentCount}枚存在します。`);
                        return;
                    }
                    if (totalCurrentMainCards + quantity > 50) {
                        alert(`メインデッキの合計が50枚を超えます。現在${totalCurrentMainCards}枚です。`);
                        return;
                    }
                    mainDeck[existingCardIndex].quantity += quantity;
                } else {
                    if (totalCurrentMainCards + quantity > 50) {
                        alert(`メインデッキの合計が50枚を超えます。現在${totalCurrentMainCards}枚です。`);
                        return;
                    }
                    mainDeck.push({ name: cardName, quantity: quantity, isAce: isAce, cardData: cardInfo });
                }
            } else if (targetDeckType === 'tactics') {
                if (cardInfo['カード種類'] !== 'タクティクスカード') {
                    alert('このカードはタクティクスカードではありません。');
                    return;
                }
                if (tacticsDeck.length >= 5) {
                    alert('タクティクスカードは5枚までです。');
                    return;
                }
                if (tacticsDeck.some(card => card.name === cardName)) {
                    alert('このタクティクスカードはすでにデッキに存在します。');
                    return;
                }
                tacticsDeck.push({ name: cardName, cardData: cardInfo });
            }

            updateDeckDisplay();
        }

        /**
         * デッキからカードを削除する共通関数
         * @param {string} cardName - 削除するカードの名前
         * @param {('leader'|'main'|'tactics')} targetDeckType - ターゲットとなるデッキの種類
         * @param {number} [quantityToRemove=1] - 削除する枚数 (メインデッキのみ有効)
         */
        function removeCardFromDeck(cardName, targetDeckType, quantityToRemove = 1) {
            if (targetDeckType === 'leader') {
                leaderDeck = leaderDeck.filter(card => card.name !== cardName);
            } else if (targetDeckType === 'main') {
                const cardIndex = mainDeck.findIndex(card => card.name === cardName);
                if (cardIndex > -1) {
                    mainDeck[cardIndex].quantity -= quantityToRemove;
                    if (mainDeck[cardIndex].quantity <= 0) {
                        mainDeck.splice(cardIndex, 1); // 0枚以下になったら配列から削除
                    }
                }
            } else if (targetDeckType === 'tactics') {
                tacticsDeck = tacticsDeck.filter(card => card.name !== cardName);
            }
            updateDeckDisplay();
        }


        /**
         * カードカタログを画像グリッドで表示する
         * @param {Array<Object>} cardsToDisplay - 表示するカードオブジェクトの配列
         * @param {string} currentDisplayTab - 現在表示しているタブ ('leader', 'main', 'tactics')
         */
        function renderImageCatalog(cardsToDisplay, currentDisplayTab) {
            catalogDisplayArea.innerHTML = ''; // Clear previous content
            const grid = document.createElement('div');
            // Apply Tailwind responsive grid classes directly
            grid.className = 'card-image-grid grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6';

            if (cardsToDisplay.length === 0) {
                grid.innerHTML = '<p class="text-center text-gray-500 italic col-span-full">該当するカードがありません。</p>';
                catalogDisplayArea.appendChild(grid);
                return;
            }

            cardsToDisplay.forEach(card => {
                const imageUrl = getCardImageUrl(card); // Pass full card object
                let quantityInDeck = 0;
                let maxQuantity = 1; // Default max for individual leader/tactics cards

                if (currentDisplayTab === 'leader') {
                    quantityInDeck = leaderDeck.some(dc => dc.name === card['カード名']) ? 1 : 0;
                    maxQuantity = 1;
                } else if (currentDisplayTab === 'main') {
                    const deckCard = mainDeck.find(dc => dc.name === card['カード名']);
                    quantityInDeck = deckCard ? deckCard.quantity : 0;
                    maxQuantity = 4; // Main deck cards can have up to 4 copies
                } else if (currentTab === 'tactics') {
                    quantityInDeck = tacticsDeck.some(dc => dc.name === card['カード名']) ? 1 : 0;
                    maxQuantity = 1;
                }

                const cardItem = document.createElement('div');
                cardItem.className = 'card-image-item';
                cardItem.setAttribute('data-card-name', card['カード名']);
                cardItem.setAttribute('data-card-type', currentDisplayTab); // For add/remove logic

                cardItem.innerHTML = `
                    <img src="${imageUrl}" alt="${card['カード名']}" onerror="this.onerror=null;this.src='https://placehold.co/150x210/cccccc/333333?text=Load+Error';">
                    <div class="card-image-controls">
                        <button class="view-detail-btn" data-card-name="${card['カード名']}">🔎</button>
                        <span class="card-image-quantity">${quantityInDeck} / ${maxQuantity}</span>
                        <button class="remove-card-btn" data-card-name="${card['カード名']}" data-card-type="${currentDisplayTab}">✕</button>
                    </div>
                `;

                // Add card to deck on image click
                cardItem.querySelector('img').addEventListener('click', () => {
                    addCardToDeck(card['カード名'], 1, currentDisplayTab);
                });

                // Remove card from deck on X button click
                cardItem.querySelector('.remove-card-btn').addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent card add click from firing
                    removeCardFromDeck(card['カード名'], currentDisplayTab);
                });

                // View detail on 🔎 button click
                cardItem.querySelector('.view-detail-btn').addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent card add click from firing
                    showCardDetailModal(card['カード名']);
                });

                grid.appendChild(cardItem);
            });
            catalogDisplayArea.appendChild(grid);
        }

        /**
         * カードカタログをテーブルで表示する (既存の機能)
         * @param {Array<Object>} cardsToDisplay - 表示するカードオブジェクトの配列
         * @param {string} currentDisplayTab - 現在表示しているタブ ('leader', 'main', 'tactics')
         */
        function renderTableCatalog(cardsToDisplay, currentDisplayTab) {
            catalogDisplayArea.innerHTML = '';
            const tableScrollContainer = document.createElement('div');
            tableScrollContainer.className = 'table-scroll-container';
            const table = document.createElement('table');
            table.className = 'card-catalog-table';
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');
            table.appendChild(thead);
            table.appendChild(tbody);

            let headers = [];
            let columnRenderers = [];
            let colspan = 0;

            if (currentDisplayTab === 'leader') {
                headers = ['カード名', 'タグ', '色', 'HP', 'ATK', 'カードテキスト', ''];
                columnRenderers = [
                    card => card['カード名'] + (card['ACE'] ? `<span class="text-red-600 font-bold">(エース)</span>` : ''),
                    card => card['タグ'] || '',
                    card => card['色'] || '',
                    card => card['覚醒前HP'] || '',
                    card => card['覚醒前ATK'] || '',
                    card => card['カードテキスト'] || ''
                ];
                colspan = headers.length;
            } else if (currentDisplayTab === 'main') {
                headers = ['カード名', '種類', '色', 'コスト', 'ビルドルール', 'カードテキスト', ''];
                columnRenderers = [
                    card => card['カード名'] + (card['ACE'] ? `<span class="text-red-600 font-bold">(エース)</span>` : ''),
                    card => card['カード種類'],
                    card => card['色'] || '',
                    card => card['コスト'] || '',
                    card => card['ビルドルール'] || '',
                    card => card['カードテキスト'] || ''
                ];
                colspan = headers.length;
            } else if (currentDisplayTab === 'tactics') {
                headers = ['カード名', '種類', 'コスト', 'カードテキスト', ''];
                columnRenderers = [
                    card => card['カード名'],
                    card => card['カード種類'],
                    card => card['コスト'] || '',
                    card => card['カードテキスト'] || ''
                ];
                colspan = headers.length;
            }

            thead.innerHTML = `<tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>`;

            if (cardsToDisplay.length === 0) {
                tbody.innerHTML = `<tr><td colspan="${colspan}" class="text-center text-gray-500 italic">該当するカードがありません。</td></tr>`;
                tableScrollContainer.appendChild(table);
                catalogDisplayArea.appendChild(tableScrollContainer);
                return;
            }

            cardsToDisplay.forEach(card => {
                const tr = document.createElement('tr');
                let tdContent = columnRenderers.map(renderer => `<td>${renderer(card)}</td>`).join('');
                
                tr.innerHTML = `
                    ${tdContent}
                    <td>
                        <div class="catalog-add-controls">
                            <input type="number" value="1" min="1" max="4" class="card-quantity-input">
                            <button class="add-card-from-catalog btn btn-primary text-sm" data-card-name="${card['カード名']}" data-card-type="${currentDisplayTab}">追加</button>
                        </div>
                    </td>
                `;
                tbody.appendChild(tr);
            });
            tableScrollContainer.appendChild(table);
            catalogDisplayArea.appendChild(tableScrollContainer);
        }

        /**
         * 現在のタブと表示モードに基づいてカタログをレンダリングする
         */
        function renderCatalog() {
            let filteredCards = [];
            let allCardsOfType = [];

            // Step 1: Filter by current tab
            if (currentTab === 'leader') {
                allCardsOfType = Object.values(allCardData).filter(card => card['カード種類'] === 'リーダーカード');
            } else if (currentTab === 'main') {
                allCardsOfType = Object.values(allCardData).filter(card => card['カード種類'] !== 'リーダーカード' && card['カード種類'] !== 'タクティクスカード');
            } else if (currentTab === 'tactics') {
                allCardsOfType = Object.values(allCardData).filter(card => card['カード種類'] === 'タクティクスカード');
            }

            // Step 2: Apply search query filter
            filteredCards = allCardsOfType.filter(card =>
                card['カード名'].toLowerCase().includes(currentSearchQuery.toLowerCase()) ||
                (card['カードテキスト'] && card['カードテキスト'].toLowerCase().includes(currentSearchQuery.toLowerCase())) ||
                (card['ビルドルール'] && card['ビルドルール'].toLowerCase().includes(currentSearchQuery.toLowerCase()))
            );

            // Step 3: Apply additional filters
            filteredCards = filteredCards.filter(card => {
                // Color filter (always applies unless hidden by UI logic)
                if (colorFilterSelect.style.display !== 'none' && selectedFilterColor !== '全て' && card['色'] !== selectedFilterColor) {
                    return false;
                }

                // Card Type filter (only applies if visible for the current tab)
                if (cardTypeFilterSelect.style.display !== 'none' && selectedFilterCardType !== '全て') {
                    if (card['カード種類'] !== selectedFilterCardType) {
                        return false;
                    }
                }
                
                // Cost filter (only applies if visible for the current tab)
                if (costFilterSelect.style.display !== 'none' && selectedFilterCost !== '全て') {
                    if (selectedFilterCost === '4+') {
                        if (parseInt(card['コスト']) < 4) {
                            return false;
                        }
                    } else {
                        if (parseInt(card['コスト']) !== parseInt(selectedFilterCost)) {
                            return false;
                        }
                    }
                }

                // Build Rule checkbox filter (only applies if visible for the current tab)
                if (buildRuleCheckboxLabel.style.display !== 'none' && onlyBuildRule && card['ビルドルール'] === '') {
                    return false;
                }

                return true;
            });

            // Step 4: Apply sorting
            const sortedCards = [...filteredCards].sort((a, b) => {
                const criterion = currentSort.criterion;
                const direction = currentSort.direction;

                const colorOrder = { '赤': 1, '青': 2, '黄': 3, '緑': 4, '無': 5, '': 99 }; // '無' added for Tactics cards, '' for unknown colors

                let compareResult = 0;

                // Primary sort for Leader/Main by '色'
                if (criterion === '色' && currentTab !== 'tactics') { // Tactics cards don't use '色' for sorting
                    const colorA = colorOrder[a['色']] || 99;
                    const colorB = colorOrder[b['色']] || 99;
                    compareResult = colorA - colorB;
                    if (compareResult !== 0) return direction === 'asc' ? compareResult : -compareResult;
                }

                // Secondary sort for Leader by 'タグ'
                if (criterion === 'タグ' && currentTab === 'leader') {
                    const tagA = a['タグ'] || '';
                    const tagB = b['タグ'] || '';
                    compareResult = tagA.localeCompare(tagB);
                    if (compareResult !== 0) return direction === 'asc' ? compareResult : -compareResult;
                }

                // Primary sort for Main/Tactics by 'コスト' (if applicable)
                if (criterion === 'コスト' && (currentTab === 'main' || currentTab === 'tactics')) {
                    const costA = parseInt(a[criterion]) || 0;
                    const costB = parseInt(b[criterion]) || 0;
                    compareResult = costA - costB;
                    if (compareResult !== 0) return direction === 'asc' ? compareResult : -compareResult;
                }

                // Primary sort for Main/Leader by 'レアリティ'
                if (criterion === 'レアリティ' && currentTab !== 'tactics') { // Tactics cards don't use 'レアリティ' for sorting
                    const rarityOrder = { 'LR': 1, 'SR': 2, 'R': 3, 'UC': 4, 'C': 5, 'TR': 6 }; // TR for Tactics
                    const rarityA = rarityOrder[a[criterion]] || 99;
                    const rarityB = rarityOrder[b[criterion]] || 99;
                    compareResult = rarityA - rarityB;
                    if (compareResult !== 0) return direction === 'asc' ? compareResult : -compareResult;
                }


                // Fallback / Primary sort by Card Name (alphabetic)
                return direction === 'asc' ?
                    (a['カード名'] || '').localeCompare(b['カード名'] || '') :
                    (b['カード名'] || '').localeCompare(a['カード名'] || '');
            });

            // Step 5: Render based on display mode
            if (displayMode === 'image') {
                renderImageCatalog(sortedCards, currentTab);
            } else {
                renderTableCatalog(sortedCards, currentTab);
            }
        }

        /**
         * フィルターとソートUIの表示/非表示、オプションの更新を行う
         */
        function updateFilterAndSortUI() {
            // Reset all filters/checkboxes to hidden initially
            colorFilterSelect.style.display = 'none';
            cardTypeFilterSelect.style.display = 'none';
            costFilterSelect.style.display = 'none';
            buildRuleCheckboxLabel.style.display = 'none';

            // Reset sort options to a default set
            sortCriterionSelect.innerHTML = `<option value="カード名">カード名でソート</option>`;

            // Update filter option display names
            colorFilterSelect.querySelector('option[value="全て"]').textContent = '色';
            cardTypeFilterSelect.querySelector('option[value="全て"]').textContent = '種類';
            costFilterSelect.querySelector('option[value="全て"]').textContent = 'コスト';


            if (currentTab === 'leader') {
                colorFilterSelect.style.display = 'inline-block'; // Show color filter for leaders
                // Add sorting options specific to Leader cards
                sortCriterionSelect.innerHTML += `
                    <option value="タグ">タグでソート</option>
                    <option value="色">色でソート</option>
                    <option value="レアリティ">レアリティでソート</option>
                `;
            } else if (currentTab === 'main') {
                colorFilterSelect.style.display = 'inline-block';
                cardTypeFilterSelect.style.display = 'inline-block';
                costFilterSelect.style.display = 'inline-block';
                buildRuleCheckboxLabel.style.display = 'flex';
                // Add sorting options specific to Main cards
                sortCriterionSelect.innerHTML += `
                    <option value="コスト">コストでソート</option>
                    <option value="レアリティ">レアリティでソート</option>
                    <option value="色">色でソート</option>
                `;
                // Main deck specific card type options
                cardTypeFilterSelect.innerHTML = `
                    <option value="全て">種類</option>
                    <option value="アタックカード">アタックカード</option>
                    <option value="メモリアカード">メモリアカード</option>
                `;
            } else if (currentTab === 'tactics') {
                // Tactics cards only have Cost and Card Name as meaningful sort/filter options
                costFilterSelect.style.display = 'inline-block';
                // Add sorting options specific to Tactics cards
                sortCriterionSelect.innerHTML += `
                    <option value="コスト">コストでソート</option>
                `;
            }

            // Ensure current sort criterion is still valid for the selected tab. If not, reset to 'カード名'.
            const validSortOptions = Array.from(sortCriterionSelect.options).map(opt => opt.value);
            if (!validSortOptions.includes(currentSort.criterion)) {
                currentSort.criterion = 'カード名';
            }
            sortCriterionSelect.value = currentSort.criterion;

            // Reflect current filter values in UI
            colorFilterSelect.value = selectedFilterColor;
            cardTypeFilterSelect.value = selectedFilterCardType;
            costFilterSelect.value = selectedFilterCost;
            buildRuleCheckbox.checked = onlyBuildRule;
        }

        /**
         * デッキ表示モーダルを表示する
         */
        function showDeckViewModal() {
            modalDeckName.textContent = deckNameInput.value.trim() || '無題のデッキ';
            modalLeaderCards.innerHTML = '';
            modalMainCards.innerHTML = '';
            modalTacticsCards.innerHTML = '';

            // Helper to create a card item with controls for the modal
            const createModalCardItem = (card, deckType, quantity = 1, maxQuantity = 1) => {
                const imageUrl = getCardImageUrl(card.cardData);
                const imgDiv = document.createElement('div');
                imgDiv.className = 'relative group w-24 h-32 overflow-hidden rounded-md shadow-md flex flex-col items-center'; // Added flex for layout
                imgDiv.innerHTML = `
                    <img src="${imageUrl}" alt="${card.name}" class="w-full h-full object-cover cursor-pointer">
                    <div class="card-image-controls absolute bottom-0 bg-white bg-opacity-90 w-full py-1">
                        <button class="view-detail-btn text-blue-500 hover:text-blue-700" data-card-name="${card.name}">🔎</button>
                        <span class="card-image-quantity text-gray-800">${quantity} / ${maxQuantity}</span>
                        <button class="remove-card-btn text-red-500 hover:text-red-700" data-card-name="${card.name}" data-card-type="${deckType}">✕</button>
                    </div>
                `;

                // Add event listeners directly to the buttons within the created item
                imgDiv.querySelector('.view-detail-btn').addEventListener('click', (event) => {
                    event.stopPropagation();
                    showCardDetailModal(card.name);
                });

                imgDiv.querySelector('.remove-card-btn').addEventListener('click', (event) => {
                    event.stopPropagation();
                    // For main deck cards, clicking 'X' reduces quantity by 1
                    if (deckType === 'main') {
                        removeCardFromDeck(card.name, deckType, 1);
                    } else { // Leader and Tactics are removed entirely
                        removeCardFromDeck(card.name, deckType);
                    }
                });

                // Add image click to increase quantity
                imgDiv.querySelector('img').addEventListener('click', () => {
                    addCardToDeck(card.name, 1, deckType);
                });

                return imgDiv;
            };

            // リーダーカード表示
            leaderDeck.forEach(card => {
                modalLeaderCards.appendChild(createModalCardItem(card, 'leader', 1, 1));
            });
            modalLeaderCount.textContent = leaderDeck.length;

            // メインデッキ表示
            mainDeck.forEach(card => {
                modalMainCards.appendChild(createModalCardItem(card, 'main', card.quantity, 4));
            });
            modalMainCount.textContent = mainDeck.reduce((sum, card) => sum + card.quantity, 0);
            modalAceCount.textContent = mainDeck.filter(c => c.isAce).reduce((sum, c) => sum + c.quantity, 0);


            // タクティクスデッキ表示
            tacticsDeck.forEach(card => {
                modalTacticsCards.appendChild(createModalCardItem(card, 'tactics', 1, 1));
            });
            modalTacticsCount.textContent = tacticsDeck.length;


            deckViewModal.classList.remove('hidden');
        }

        /**
         * カード詳細モーダルを表示する
         * @param {string} cardName - 表示するカードの名前
         */
        function showCardDetailModal(cardName) {
            const cardInfo = allCardData[cardName];
            if (!cardInfo) {
                alert('カード詳細が見つかりません。');
                return;
            }

            modalCardImage.src = getCardImageUrl(cardInfo); // Pass cardInfo
            modalCardImage.alt = cardInfo['カード名'];
            modalCardName.textContent = cardInfo['カード名'];
            modalCardNumber.textContent = `カードナンバー: ${cardInfo['カードナンバー']}`;
            modalCardType.textContent = `カード種類: ${cardInfo['カード種類']}`;
            modalCardColor.textContent = `色: ${cardInfo['色']}`;
            modalCardCost.textContent = `コスト: ${cardInfo['コスト']}`;
            modalCardRarity.textContent = `レアリティ: ${cardInfo['レアリティ']}`;
            modalCardRules.textContent = cardInfo['ビルドルール'] ? `ビルドルール: ${cardInfo['ビルドルール']}` : '';
            modalCardTag.textContent = cardInfo['タグ'] ? `タグ: ${cardInfo['タグ']}` : '';
            
            let stats = [];
            if (cardInfo['覚醒前ATK'] && cardInfo['覚醒後ATK']) {
                stats.push(`ATK: ${cardInfo['覚醒前ATK']} / ${cardInfo['覚醒後ATK']}`);
            }
            if (cardInfo['覚醒前HP'] && cardInfo['覚醒後HP']) {
                stats.push(`HP: ${cardInfo['覚醒前HP']} / ${cardInfo['覚醒後HP']}`);
            }
            modalCardStats.textContent = stats.join(' | ');

            modalCardText.textContent = cardInfo['カードテキスト'];

            cardDetailModal.classList.remove('hidden');
        }

        /**
         * デッキ画像を生成して表示する
         */
        async function generateDeckImage() {
            loadingIndicator.classList.remove('hidden'); // Show loading indicator at the very start
            try {
                const validations = validateDeck();
                if (!validations.isLeaderValid || !validations.isMainValid || !validations.isTacticsValid) {
                    alert('デッキ構築ルールに問題があるため、デッキ画像は生成できません。上記のバリデーションメッセージを確認してください。');
                    loadingIndicator.classList.add('hidden'); // Ensure loading indicator is hidden on validation failure
                    return;
                }

                const CARD_WIDTH = 150;
                const CARD_HEIGHT = 210;
                const PADDING = 10;
                const TEXT_HEIGHT = 20; // Space for card name below image
                const QUANTITY_FONT_SIZE = 24; // Larger font for quantity
                const NUM_COLUMNS = 7; // Fixed number of columns

                const cardsToDraw = []; // Array to hold all cards (or empty slots) to be drawn

                // 1行目: リーダーカード (4枚 + 空欄3枚)
                const leaderCardsFormatted = leaderDeck.map(card => ({ cardData: card.cardData, displayQuantity: 1, type: 'leader' }));
                for (let i = 0; i < NUM_COLUMNS; i++) {
                    cardsToDraw.push(leaderCardsFormatted[i] || { cardData: null, type: 'empty' });
                }

                // メインデッキのソート (カード種類、色、コスト、名前の順)
                const sortedMainDeckToDraw = [];
                // Flatten mainDeck to individual card entries for drawing, maintaining quantity
                mainDeck.forEach(card => {
                    for (let i = 0; i < card.quantity; i++) {
                        sortedMainDeckToDraw.push({ cardData: card.cardData, displayQuantity: card.quantity, type: 'main' });
                    }
                });

                sortedMainDeckToDraw.sort((a, b) => {
                    const typeOrder = { 'アタックカード': 1, 'メモリアカード': 2 };
                    const typeA = typeOrder[a.cardData['カード種類']] || 99;
                    const typeB = typeOrder[b.cardData['カード種類']] || 99;
                    if (typeA !== typeB) return typeA - typeB;

                    const colorOrder = { '赤': 1, '青': 2, '黄': 3, '緑': 4, '': 5 };
                    const colorA = colorOrder[a.cardData['色']] || 99;
                    const colorB = colorOrder[b.cardData['色']] || 99;
                    if (colorA !== colorB) return colorA - colorB;

                    const costA = parseInt(a.cardData['コスト']) || 0;
                    const costB = parseInt(b.cardData['コスト']) || 0;
                    if (costA !== costB) return costA - costB;

                    return a.cardData['カード名'].localeCompare(b.cardData['カード名']);
                });
                
                // メインデッキのカードを追加
                sortedMainDeckToDraw.forEach(card => cardsToDraw.push(card));

                // 最後の行: タクティクスカード (5枚 + 空欄2枚)
                const tacticsCardsFormatted = tacticsDeck.map(card => ({ cardData: card.cardData, displayQuantity: 1, type: 'tactics' }));
                const currentLastRowLength = cardsToDraw.length % NUM_COLUMNS;
                // Add empty slots to fill current last row before adding tactics cards, if it's not the leader row
                if (currentLastRowLength !== 0) {
                     for (let i = currentLastRowLength; i < NUM_COLUMNS; i++) {
                        cardsToDraw.push({ cardData: null, type: 'empty' });
                    }
                }
                
                // Add tactics cards to a new row (or continuing the last one if it was full)
                for (let i = 0; i < NUM_COLUMNS; i++) {
                    cardsToDraw.push(tacticsCardsFormatted[i] || { cardData: null, type: 'empty' });
                }

                // Calculate total rows needed
                const numRows = Math.ceil(cardsToDraw.length / NUM_COLUMNS);

                // キャンバスサイズの計算
                const CANVAS_WIDTH = NUM_COLUMNS * (CARD_WIDTH + PADDING) + PADDING;
                const CANVAS_HEIGHT = numRows * (CARD_HEIGHT + TEXT_HEIGHT + PADDING) + PADDING;

                deckCanvas.width = CANVAS_WIDTH;
                deckCanvas.height = CANVAS_HEIGHT;
                const ctx = deckCanvas.getContext('2d');

                ctx.fillStyle = '#f0f2f5'; // アプリ全体の背景色と同じにする
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                const imagePromises = cardsToDraw.map(item => {
                    if (!item.cardData) { // 空欄の場合は画像を読み込まない
                        return Promise.resolve(null);
                    }
                    const img = new Image();
                    img.crossOrigin = 'Anonymous'; // ⭐ IMPORTANT: Add this line for CORS
                    img.src = getCardImageUrl(item.cardData);
                    return new Promise((resolve) => {
                        img.onload = () => resolve(img);
                        img.onerror = () => {
                            console.error("Failed to load image for card:", item.cardData['カード名']);
                            const placeholder = new Image();
                            placeholder.src = `https://placehold.co/${CARD_WIDTH}x${CARD_HEIGHT}/cccccc/333333?text=Load+Error\\n${item.cardData['カード名']}`;
                            placeholder.onload = () => resolve(placeholder);
                            placeholder.onerror = () => resolve(null);
                        };
                    });
                });

                const loadedImages = await Promise.all(imagePromises);
                
                loadedImages.forEach((img, index) => {
                    const item = cardsToDraw[index];
                    const col = index % NUM_COLUMNS;
                    const row = Math.floor(index / NUM_COLUMNS);
                    const x = PADDING + col * (CARD_WIDTH + PADDING);
                    const y = PADDING + row * (CARD_HEIGHT + TEXT_HEIGHT + PADDING);

                    if (img) {
                        ctx.drawImage(img, x, y, CARD_WIDTH, CARD_HEIGHT);

                        // カード名を描画
                        ctx.fillStyle = '#333';
                        ctx.font = '600 12px Inter';
                        ctx.textAlign = 'center';
                        const cardName = item.cardData['カード名'];
                        const textY = y + CARD_HEIGHT + TEXT_HEIGHT / 2 + 5;
                        ctx.fillText(cardName, x + CARD_WIDTH / 2, textY, CARD_WIDTH - 4);

                        // メインデッキカードで枚数が1より大きい場合に枚数を描画
                        if (item.type === 'main' && item.displayQuantity > 1) {
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // 数量の背景色
                            ctx.beginPath();
                            const radius = QUANTITY_FONT_SIZE / 2 + 8;
                            const circleX = x + CARD_WIDTH - radius + 5;
                            const circleY = y + CARD_HEIGHT - radius + 5;
                            ctx.arc(circleX, circleY, radius, 0, Math.PI * 2, true);
                            ctx.fill();

                            ctx.fillStyle = 'white'; // 数量の文字色
                            ctx.font = `bold ${QUANTITY_FONT_SIZE}px Inter`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(item.displayQuantity.toString(), circleX, circleY + 2);
                        }
                    } else {
                        // 空欄の場合、背景色(#f0f2f5)のみ表示 (何もしない)
                    }
                });

                const dataURL = deckCanvas.toDataURL('image/png');
                
                // タイムスタンプ付きのファイル名を生成
                const now = new Date();
                const timestamp = now.getFullYear().toString() +
                                  (now.getMonth() + 1).toString().padStart(2, '0') +
                                  now.getDate().toString().padStart(2, '0') +
                                  now.getHours().toString().padStart(2, '0') +
                                  now.getMinutes().toString().padStart(2, '0') +
                                  now.getSeconds().toString().padStart(2, '0');
                downloadDeckImageBtn.download = `XrossStars_Deck_${timestamp}.png`;
                downloadDeckImageBtn.href = dataURL;
                
                deckImageModal.classList.remove('hidden');

            } catch (error) {
                console.error("デッキ画像の生成中にエラーが発生しました:", error);
                alert(`デッキ画像の生成中にエラーが発生しました。詳細: ${error.message}`);
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }


        // イベントリスナー
        showLeaderCatalogBtn.addEventListener('click', () => { currentTab = 'leader'; renderCatalog(); updateFilterAndSortUI(); });
        showMainCatalogBtn.addEventListener('click', () => { currentTab = 'main'; renderCatalog(); updateFilterAndSortUI(); });
        showTacticsCatalogBtn.addEventListener('click', () => { currentTab = 'tactics'; renderCatalog(); updateFilterAndSortUI(); });
        showDeckBtn.addEventListener('click', showDeckViewModal);
        generateDeckImageBtn.addEventListener('click', generateDeckImage); // New button event listener
        closeDeckViewModalBtn.addEventListener('click', () => deckViewModal.classList.add('hidden'));
        closeCardDetailModalBtn.addEventListener('click', () => cardDetailModal.classList.add('hidden'));
        closeDeckImageModalBtn.addEventListener('click', () => deckImageModal.classList.add('hidden')); // Close deck image modal

        // 検索入力時の処理
        searchCatalogInput.addEventListener('input', () => {
            currentSearchQuery = searchCatalogInput.value.trim();
            renderCatalog();
        });

        // フィルター変更時の処理
        colorFilterSelect.addEventListener('change', (event) => {
            selectedFilterColor = event.target.value;
            renderCatalog();
        });

        cardTypeFilterSelect.addEventListener('change', (event) => {
            selectedFilterCardType = event.target.value;
            renderCatalog();
        });

        costFilterSelect.addEventListener('change', (event) => {
            selectedFilterCost = event.target.value;
            renderCatalog();
        });

        buildRuleCheckbox.addEventListener('change', (event) => {
            onlyBuildRule = event.target.checked;
            renderCatalog();
        });

        // ソート基準変更時の処理
        sortCriterionSelect.addEventListener('change', (event) => {
            currentSort.criterion = event.target.value;
            renderCatalog();
        });

        // ソート方向変更時の処理
        sortDirectionBtn.addEventListener('click', () => {
            currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            sortDirectionBtn.textContent = currentSort.direction === 'asc' ? '昇順' : '降順';
            renderCatalog();
        });

        // 表示モード切り替え
        toggleDisplayBtn.addEventListener('click', () => {
            displayMode = displayMode === 'image' ? 'table' : 'image';
            toggleDisplayBtn.textContent = `表示切替: ${displayMode === 'image' ? '画像一覧' : 'テーブル'}`;
            renderCatalog();
        });


        // カードカタログからの追加（共通化 - テーブル表示時のボタン）
        // イベント委譲で処理
        catalogDisplayArea.addEventListener('click', (event) => {
            if (event.target.classList.contains('add-card-from-catalog')) {
                const cardName = event.target.dataset.cardName;
                const cardType = event.target.dataset.cardType;
                const quantityInput = event.target.closest('.catalog-add-controls').querySelector('.card-quantity-input');
                const quantity = parseInt(quantityInput.value, 10);
                
                addCardToDeck(cardName, quantity, cardType);
            }
        });


        /**
         * デッキデータをJSON文字列としてエクスポートする
         */
        exportDeckBtn.addEventListener('click', () => {
            const exportedLeader = {};
            leaderDeck.forEach(card => {
                const cardNumPrefix = card.cardData['カードナンバー'] ? card.cardData['カードナンバー'].split('/')[0] : card.name;
                exportedLeader[cardNumPrefix] = 1; // リーダーカードは常に1枚
            });

            const exportedMain = {};
            mainDeck.forEach(card => {
                const cardNumPrefix = card.cardData['カードナンバー'] ? card.cardData['カードナンバー'].split('/')[0] : card.name;
                exportedMain[cardNumPrefix] = card.quantity;
            });

            const exportedTactics = {};
            tacticsDeck.forEach(card => {
                const cardNumPrefix = card.cardData['カードナンバー'] ? card.cardData['カードナンバー'].split('/')[0] : card.name;
                exportedTactics[cardNumPrefix] = 1; // タクティクスカードは常に1枚
            });

            const deckData = {
                deckName: deckNameInput.value.trim(),
                deck: {
                    LEADER: exportedLeader,
                    MAIN: exportedMain,
                    TACTICS: exportedTactics
                }
            };
            deckDataTextarea.value = JSON.stringify(deckData, null, 2); // Pretty print JSON
            copyExportedDataBtn.classList.remove('hidden');
            importExportMessage.classList.remove('hidden');
            importExportMessage.className = 'validation-message validation-success';
            importExportMessage.textContent = 'デッキデータがエクスポートされました。テキストエリアからコピーしてください。';
        });

        /**
         * テキストエリアのデータをクリップボードにコピーする
         */
        copyExportedDataBtn.addEventListener('click', () => {
            deckDataTextarea.select();
            document.execCommand('copy');
            importExportMessage.className = 'validation-message validation-success';
            importExportMessage.textContent = 'デッキデータがクリップボードにコピーされました！';
        });

        /**
         * テキストエリアのJSONデータからデッキをインポートする
         */
        importDeckBtn.addEventListener('click', () => {
            const importText = deckDataTextarea.value.trim();
            if (!importText) {
                importExportMessage.className = 'validation-message validation-warning';
                importExportMessage.textContent = 'インポートするデッキデータがありません。テキストエリアにデータを貼り付けてください。';
                return;
            }

            try {
                const importedStructure = JSON.parse(importText);
                const importedData = importedStructure.deck;

                // データの妥当性チェック
                if (!importedData || !importedData.LEADER || !importedData.MAIN || !importedData.TACTICS) {
                    throw new Error('無効なデッキデータ形式です。必要なセクション（LEADER, MAIN, TACTICS）が見つかりません。');
                }

                const newLeaderDeck = [];
                const newMainDeck = [];
                const newTacticsDeck = [];

                let importError = false;

                // リーダーデッキのインポート
                const leaderCardEntries = Object.entries(importedData.LEADER);
                if (leaderCardEntries.length > 4) {
                    alert('インポートするリーダーカードが多すぎます（最大4枚）。');
                    importError = true;
                } else {
                    for (const [cardNumPrefix, quantity] of leaderCardEntries) {
                        const cardInfo = allCardDataByNumberPrefix[cardNumPrefix];
                        if (!cardInfo || cardInfo['カード種類'] !== 'リーダーカード') {
                            alert(`カード番号 "${cardNumPrefix}" は有効なリーダーカードではありません。`);
                            importError = true;
                            break;
                        }
                        if (newLeaderDeck.some(lc => lc.name === cardInfo['カード名'])) {
                            alert(`リーダーカード "${cardInfo['カード名']}" はすでにデッキに重複しています（カード番号: ${cardNumPrefix}）。`);
                            importError = true;
                            break;
                        }
                        if (quantity !== 1) { // リーダーカードは常に1枚であることを確認
                            alert(`リーダーカード "${cardInfo['カード名']}" の枚数が不正です（カード番号: ${cardNumPrefix}）。リーダーカードは1枚のみ追加できます。`);
                            // importError = true; // エラーにするかは要検討
                        }
                        newLeaderDeck.push({ name: cardInfo['カード名'], cardData: cardInfo });
                    }
                }

                // メインデッキのインポート
                if (!importError) {
                    let totalImportedMainCards = 0;
                    const importedMainCardCounts = {};
                    for (const [cardNumPrefix, quantity] of Object.entries(importedData.MAIN)) {
                        const cardInfo = allCardDataByNumberPrefix[cardNumPrefix];
                        if (!cardInfo || (cardInfo['カード種類'] === 'リーダーカード' || cardInfo['カード種類'] === 'タクティクスカード')) {
                            alert(`カード番号 "${cardNumPrefix}" は有効なメインデッキカードではありません。`);
                            importError = true;
                            break;
                        }
                        if (quantity < 1 || quantity > 4) {
                            alert(`カード番号 "${cardNumPrefix}" の枚数が不正です（1〜4枚）。`);
                            importError = true;
                            break;
                        }
                        importedMainCardCounts[cardInfo['カード名']] = (importedMainCardCounts[cardInfo['カード名']] || 0) + quantity;
                        if (importedMainCardCounts[cardInfo['カード名']] > 4) {
                            alert(`同名カード "${cardInfo['カード名']}" が4枚を超えています（カード番号: ${cardNumPrefix}）。`);
                            importError = true;
                            break;
                        }
                        totalImportedMainCards += quantity;
                        newMainDeck.push({ name: cardInfo['カード名'], quantity: quantity, isAce: cardInfo['ACE'] === 'ACE' || cardInfo['ACE'] === 'エース', cardData: cardInfo });
                    }
                    if (!importError && totalImportedMainCards !== 50) {
                        alert(`メインデッキの合計枚数が50枚ではありません（現在 ${totalImportedMainCards}枚）。`);
                        // importError = true; // デッキ構築アプリのバリデーションに任せるため、ここではブロックしない
                    }
                    if (!importError) {
                        let totalImportedAceCards = newMainDeck.filter(c => c.isAce).reduce((sum, c) => sum + c.quantity, 0);
                        if (totalImportedAceCards > 8) {
                            alert(`メインデッキのエースカードが8枚を超えています（現在 ${totalImportedAceCards}枚）。`);
                            // importError = true; // デッキ構築アプリのバリデーションに任せるため、ここではブロックしない
                        }
                    }
                }

                // タクティクスデッキのインポート
                if (!importError) {
                    const tacticsCardEntries = Object.entries(importedData.TACTICS);
                    if (tacticsCardEntries.length > 5) {
                        alert('インポートするタクティクスカードが多すぎます（最大5枚）。');
                        importError = true;
                    } else {
                        for (const [cardNumPrefix, quantity] of tacticsCardEntries) {
                            const cardInfo = allCardDataByNumberPrefix[cardNumPrefix];
                            if (!cardInfo || cardInfo['カード種類'] !== 'タクティクスカード') {
                                alert(`カード番号 "${cardNumPrefix}" は有効なタクティクスカードではありません。`);
                                importError = true;
                                break;
                            }
                            if (newTacticsDeck.some(tc => tc.name === cardInfo['カード名'])) {
                                alert(`タクティクスカード "${cardInfo['カード名']}" はすでにデッキに存在します（カード番号: ${cardNumPrefix}）。`);
                                importError = true;
                                break;
                            }
                            if (quantity !== 1) { // タクティクスカードは常に1枚であることを確認
                                alert(`タクティクスカード "${cardInfo['カード名']}" の枚数が不正です（カード番号: ${cardNumPrefix}）。タクティクスカードは1枚のみ追加できます。`);
                                // importError = true; // エラーにするかは要検討
                            }
                            newTacticsDeck.push({ name: cardInfo['カード名'], cardData: cardInfo });
                        }
                    }
                }

                if (!importError) {
                    leaderDeck = newLeaderDeck;
                    mainDeck = newMainDeck;
                    tacticsDeck = newTacticsDeck;
                    deckNameInput.value = importedStructure.deckName || '';
                    updateDeckDisplay();
                    importExportMessage.className = 'validation-message validation-success';
                    importExportMessage.textContent = 'デッキデータが正常にインポートされました！';
                    copyExportedDataBtn.classList.add('hidden'); // Hide copy button after import
                } else {
                    importExportMessage.className = 'validation-message validation-error';
                    importExportMessage.textContent = 'デッキデータのインポートに失敗しました。詳細については上記のエラーメッセージを確認してください。';
                }

            } catch (error) {
                console.error('デッキデータのパースまたはインポート中にエラーが発生しました:', error);
                importExportMessage.className = 'validation-message validation-error';
                importExportMessage.textContent = `デッキデータのインポートに失敗しました。JSON形式が正しいか確認してください。エラー: ${error.message}`;
            }
        });

        // サンプルデッキを生成する関数 (今回は使用しないためコメントアウト)
        /*
        function generateSampleDeck() {
            const sampleDeckData = {
                "deckName": "サンプルデッキ (青単)",
                "deck": {
                    "LEADER": {
                        "BP01-005": 1, // Kamito
                        "BP01-006": 1, // 渋谷ハル
                        "BP01-007": 1, // 白雪レイド
                        "BP01-008": 1  // 英リサ
                    },
                    "MAIN": {
                        "BP01-026": 4, // CLUTCH!!! (ACE)
                        "BP01-033": 4, // ブリッツブラスト
                        "BP01-032": 4, // ドリル開錠
                        "BP01-030": 4, // 神速フリック
                        "BP01-027": 4, // フラッシュバン
                        "BP01-068": 4, // 運命のルーレット
                        "BP01-069": 4, // 運もミスもない
                        "BP01-066": 4, // 博聞強記
                        "BP01-034": 4, // 巧みな裏取り
                        "BP01-062": 4, // Never Fall (ACE)
                        "BP01-070": 4, // BEAUTY SALON -HANABUSA-
                        "BP01-064": 4, // ゾーン状態
                        "BP01-028": 2  // リスキーエントリー (残りの2枚)
                    },
                    "TACTICS": {
                        "BP01-093": 1, // ジャミングパルス
                        "BP01-094": 1, // 復活ポータル
                        "BP01-095": 1, // ライトシールド
                        "BP01-096": 1, // ボディアーマー
                        "BP01-091": 1  // 救急キット
                    }
                }
            };

            // デッキをクリア
            leaderDeck = [];
            mainDeck = [];
            tacticsDeck = [];
            deckNameInput.value = sampleDeckData.deckName;

            let importError = false;

            // リーダーデッキをインポート
            for (const cardNumPrefix in sampleDeckData.deck.LEADER) {
                const cardInfo = allCardDataByNumberPrefix[cardNumPrefix];
                if (cardInfo && cardInfo['カード種類'] === 'リーダーカード') {
                    if (!leaderDeck.some(lc => lc.name === cardInfo['カード名'])) {
                        leaderDeck.push({ name: cardInfo['カード名'], cardData: cardInfo });
                    }
                } else {
                    console.warn(`Sample leader card "${cardNumPrefix}" not found or is not a leader card.`);
                    importError = true;
                }
            }

            // メインデッキをインポート
            for (const cardNumPrefix in sampleDeckData.deck.MAIN) {
                const quantity = sampleDeckData.deck.MAIN[cardNumPrefix];
                const cardInfo = allCardDataByNumberPrefix[cardNumPrefix];
                if (cardInfo && cardInfo['カード種類'] !== 'リーダーカード' && cardInfo['カード種類'] !== 'タクティクスカード') {
                    const isAce = cardInfo['ACE'] === 'ACE' || cardInfo['ACE'] === 'エース';
                    mainDeck.push({ name: cardInfo['カード名'], quantity: quantity, isAce: isAce, cardData: cardInfo });
                } else {
                    console.warn(`Sample main card "${cardNumPrefix}" not found or is not a main deck card.`);
                    importError = true;
                }
            }

            // タクティクスデッキをインポート
            for (const cardNumPrefix in sampleDeckData.deck.TACTICS) {
                const cardInfo = allCardDataByNumberPrefix[cardNumPrefix];
                if (cardInfo && cardInfo['カード種類'] === 'タクティクスカード') {
                    if (!tacticsDeck.some(tc => tc.name === cardInfo['カード名'])) {
                        tacticsDeck.push({ name: cardInfo['カード名'], cardData: cardInfo });
                    }
                } else {
                    console.warn(`Sample tactics card "${cardNumPrefix}" not found or is not a tactics card.`);
                    importError = true;
                }
            }
            
            updateDeckDisplay();

            if (importError) {
                importExportMessage.className = 'validation-message validation-warning';
                importExportMessage.textContent = 'サンプルデッキの一部カードが見つからないか、タイプが正しくないため、完全にロードされませんでした。';
            } else {
                importExportMessage.classList.add('hidden'); // Clear previous message
            }
        }
        */

        // デッキ入出力セクションの表示/非表示切り替え
        toggleExportImportBtn.addEventListener('click', () => {
            exportImportContent.classList.toggle('hidden');
        });


        // 初期ロード時にカードデータを読み込み、オートコンプリートを設定
        window.onload = async () => {
            await loadCardData();
            // generateSampleDeck(); // デフォルトデッキは不要のためコメントアウト
            renderCatalog(); // Initial render of the leader catalog view
            updateFilterAndSortUI(); // Initial filter/sort UI update
        };
    </script>
</body>
</html>
